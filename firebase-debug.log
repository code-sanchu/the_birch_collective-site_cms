[debug] [2023-07-18T14:47:09.427Z] ----------------------------------------------------------------------
[debug] [2023-07-18T14:47:09.429Z] Command:       /home/ruben/.nvm/versions/node/v18.16.0/bin/node /home/ruben/.nvm/versions/node/v18.16.0/bin/firebase emulators:start --import=./db-local-data --export-on-exit=./db-local-data
[debug] [2023-07-18T14:47:09.430Z] CLI Version:   12.4.0
[debug] [2023-07-18T14:47:09.430Z] Platform:      linux
[debug] [2023-07-18T14:47:09.431Z] Node Version:  v18.16.0
[debug] [2023-07-18T14:47:09.433Z] Time:          Tue Jul 18 2023 15:47:09 GMT+0100 (British Summer Time)
[debug] [2023-07-18T14:47:09.433Z] ----------------------------------------------------------------------
[debug] 
[debug] [2023-07-18T14:47:09.498Z] Object ".extensions" in "firebase.json" has unknown property: {"additionalProperty":"storage-resize-images"}
[debug] [2023-07-18T14:47:09.501Z] > command requires scopes: ["email","openid","https://www.googleapis.com/auth/cloudplatformprojects.readonly","https://www.googleapis.com/auth/firebase","https://www.googleapis.com/auth/cloud-platform"]
[debug] [2023-07-18T14:47:09.501Z] > authorizing via signed-in user (a.ruben00001@gmail.com)
[debug] [2023-07-18T14:47:09.630Z] java version "20.0.1" 2023-04-18

[debug] [2023-07-18T14:47:09.630Z] Java(TM) SE Runtime Environment (build 20.0.1+9-29)
Java HotSpot(TM) 64-Bit Server VM (build 20.0.1+9-29, mixed mode, sharing)

[debug] [2023-07-18T14:47:09.635Z] Parsed Java major version: 20
[info] i  emulators: Starting emulators: auth, functions, firestore, storage, extensions {"metadata":{"emulator":{"name":"hub"},"message":"Starting emulators: auth, functions, firestore, storage, extensions"}}
[debug] [2023-07-18T14:47:09.638Z] > refreshing access token with scopes: []
[debug] [2023-07-18T14:47:09.640Z] >>> [apiv2][query] POST https://www.googleapis.com/oauth2/v3/token [none]
[debug] [2023-07-18T14:47:09.640Z] >>> [apiv2][body] POST https://www.googleapis.com/oauth2/v3/token [omitted]
[debug] [2023-07-18T14:47:09.750Z] <<< [apiv2][status] POST https://www.googleapis.com/oauth2/v3/token 200
[debug] [2023-07-18T14:47:09.750Z] <<< [apiv2][body] POST https://www.googleapis.com/oauth2/v3/token [omitted]
[debug] [2023-07-18T14:47:09.756Z] >>> [apiv2][query] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop [none]
[debug] [2023-07-18T14:47:09.996Z] <<< [apiv2][status] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop 200
[debug] [2023-07-18T14:47:09.996Z] <<< [apiv2][body] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop {"projectId":"birch-collective-develop","projectNumber":"796296843255","displayName":"birch-collective-develop","name":"projects/birch-collective-develop","resources":{"hostingSite":"birch-collective-develop","storageBucket":"birch-collective-develop.appspot.com","locationId":"europe-west2"},"state":"ACTIVE","etag":"1_83a82fa5-bad8-492e-952a-94b81202b519"}
[debug] [2023-07-18T14:47:09.999Z] Successfully read params from storage-resize-images.env
[debug] [2023-07-18T14:47:10.000Z] Error: ENOENT: no such file or directory, open '/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/extensions/storage-resize-images.env.default'
[debug] [2023-07-18T14:47:10.000Z] Error: ENOENT: no such file or directory, open '/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/extensions/storage-resize-images.env.796296843255'
[debug] [2023-07-18T14:47:10.000Z] Error: ENOENT: no such file or directory, open '/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/extensions/storage-resize-images.env.birch-collective-develop'
[debug] [2023-07-18T14:47:10.000Z] Error: ENOENT: no such file or directory, open '/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/extensions/storage-resize-images.env.local'
[debug] [2023-07-18T14:47:10.001Z] >>> [apiv2][query] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop/adminSdkConfig [none]
[debug] [2023-07-18T14:47:10.185Z] <<< [apiv2][status] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop/adminSdkConfig 200
[debug] [2023-07-18T14:47:10.185Z] <<< [apiv2][body] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop/adminSdkConfig {"projectId":"birch-collective-develop","storageBucket":"birch-collective-develop.appspot.com","locationId":"europe-west2"}
[debug] [2023-07-18T14:47:10.188Z] >>> [apiv2][query] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop [none]
[debug] [2023-07-18T14:47:10.410Z] <<< [apiv2][status] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop 200
[debug] [2023-07-18T14:47:10.410Z] <<< [apiv2][body] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop {"projectId":"birch-collective-develop","projectNumber":"796296843255","displayName":"birch-collective-develop","name":"projects/birch-collective-develop","resources":{"hostingSite":"birch-collective-develop","storageBucket":"birch-collective-develop.appspot.com","locationId":"europe-west2"},"state":"ACTIVE","etag":"1_83a82fa5-bad8-492e-952a-94b81202b519"}
[debug] [2023-07-18T14:47:10.411Z] >>> [apiv2][query] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images [none]
[debug] [2023-07-18T14:47:11.058Z] <<< [apiv2][status] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images 200
[debug] [2023-07-18T14:47:11.059Z] <<< [apiv2][body] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images {"name":"publishers/firebase/extensions/storage-resize-images","ref":"firebase/storage-resize-images","latestVersion":"0.1.38","latestVersionCreateTime":"2023-07-12T08:31:00.938559Z","state":"PUBLISHED","createTime":"2021-03-18T22:07:59.572345Z","iconUri":"https://storage.googleapis.com/firebase-extensions-icons/extension_icons/firebase/resize_images_120@2x.png","publisher":{"displayName":"Firebase","iconUri":"https://storage.googleapis.com/firebase-extensions-icons/publisher_icons/firebase/firebase_128dp.png"},"repoUri":"https://github.com/firebase/extensions","metrics":{"activeInstallCount":"18600"},"latestApprovedVersion":"0.1.38"}
[debug] [2023-07-18T14:47:11.059Z] >>> [apiv2][query] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images/versions filter=&showPrereleases=true&pageSize=100&pageToken=
[debug] [2023-07-18T14:47:12.232Z] <<< [apiv2][status] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images/versions 200
[debug] [2023-07-18T14:47:12.239Z] <<< [apiv2][body] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images/versions {"extensionVersions":[{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.0","ref":"firebase/storage-resize-images@0.1.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores both images in the same Cloud Storage bucket.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/commits/master","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Deployment location","type":"SELECT","description":"Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1"},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"(.)+\\.(.)+\\.(.)+","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-image).\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n\n- Creates resized image(s) with your specfied dimensions.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# storage-resize-images\n\n**VERSION**: 0.1.0\n\n**DESCRIPTION**: Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.\n\n\n\n**CONFIGURATION PARAMETERS:**\n\n* Deployment location: Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-image).\n\n\n* Cache-Control header for resized images: Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n\n\n\n\n**CLOUD FUNCTIONS CREATED:**\n\n* generateResizedImage (google.storage.object.finalize)\n\n\n\n**DETAILS**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n**APIS USED**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**ACCESS REQUIRED**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"ae8734a79a3808c0e5baadb2129a07db978b017bcfa6aa3dd974a3b87cdccc7d","createTime":"2019-09-18T20:52:33.938873796Z","id":"0.1.0","releaseNotes":"Initial release of the _Resize Images_ extension.\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"500"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.1","ref":"firebase/storage-resize-images@0.1.1","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.1","description":"Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores both images in the same Cloud Storage bucket.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/releases","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Deployment location","type":"SELECT","description":"Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1"},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"(.)+\\.(.)+\\.(.)+","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n\n- Creates resized image(s) with your specfied dimensions.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# storage-resize-images\n\n**VERSION**: 0.1.0\n\n**DESCRIPTION**: Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.\n\n\n\n**CONFIGURATION PARAMETERS:**\n\n* Deployment location: Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Cache-Control header for resized images: Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n\n\n\n\n**CLOUD FUNCTIONS CREATED:**\n\n* generateResizedImage (google.storage.object.finalize)\n\n\n\n**DETAILS**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n**APIS USED**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**ACCESS REQUIRED**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"0e640d83d7a7df47082e1ecb8ee586aaf547cf7f22ff1b37f86f04ed10284a55","createTime":"2019-10-17T17:19:34.531333517Z","id":"0.1.1","releaseNotes":"fixed - Fixed bug where certain edge cases led to already resized image being resized again. (issue #7)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"700"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.10","ref":"firebase/storage-resize-images@0.1.10","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.10","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"5b6aaad19e4055fd5a4d43a3310e0b2d1fad45d097b924d15cffb92419949f4a","createTime":"2020-06-25T17:23:56.517417Z","id":"0.1.10","releaseNotes":"fixed - A fresh token is now generated for each resized image. (Issue #323, PR #351)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"1500"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.11","ref":"firebase/storage-resize-images@0.1.11","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.11","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nruntime: nodejs10\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"a6334c9b51015839f41340e8d8edcf420d0028fea6ca6dcf3c9fbc3269b975c1","createTime":"2020-09-01T17:11:44.235295Z","id":"0.1.11","releaseNotes":"feature - Update Cloud Functions runtime to Node.js 10.\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"100"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.12","ref":"firebase/storage-resize-images@0.1.12","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.12","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nruntime: nodejs10\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"137bb35c38deb264c2ab107b4565ddea56dcef315b6f682317599b74105f59d0","createTime":"2020-09-10T17:15:34.956867Z","id":"0.1.12","releaseNotes":"fixed - ignore gzipped images (PR #417)\n\nfeature - Add new Cloud Functions locations. For more information about locations and their pricing tiers, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"600"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.13","ref":"firebase/storage-resize-images@0.1.13","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.13","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs10\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred type","type":"SELECT","description":"The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","options":[{"value":"jpg","label":"jpg"},{"value":"png","label":"png"},{"value":"webp","label":"webp"},{"value":"tiff","label":"tiff"},{"value":"false","label":"Do not convert"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"707fa9ef9d2b8131dc232f5e096a8cecdbcff237137d04e8c65333c32089f646","createTime":"2020-11-05T17:03:34.934877Z","id":"0.1.13","releaseNotes":"feature - Add new parameter to optionally convert each uploaded image to a different image content-type (PR #483)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"100"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.14","ref":"firebase/storage-resize-images@0.1.14","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.14","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs10\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred type","type":"SELECT","description":"The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","options":[{"value":"jpg","label":"jpg"},{"value":"png","label":"png"},{"value":"webp","label":"webp"},{"value":"tiff","label":"tiff"},{"value":"false","label":"Do not convert"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred type: The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"bd8a63899ae4900c93c1f7f937c6ce1980572cb1fab47e6b2fe2ebb9766d4806","createTime":"2020-11-19T19:40:37.624195Z","id":"0.1.14","releaseNotes":"feature - Added a \"delete only on success\" option to the `DELETE_ORIGINAL_FILE` param (#479)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"100"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.16","ref":"firebase/storage-resize-images@0.1.16","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.16","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs10\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred type","type":"SELECT","description":"The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","options":[{"value":"jpg","label":"jpg"},{"value":"png","label":"png"},{"value":"webp","label":"webp"},{"value":"tiff","label":"tiff"},{"value":"false","label":"Do not convert"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred type: The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"39a474a801a2ec9906dd0489f50ea3caf18866d8260b2e201a519c02ab4bc4af","createTime":"2020-12-10T18:42:54.259365Z","id":"0.1.16","releaseNotes":"feature - Adds support for absolute paths restrictions for Storage Resize Image (#427)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"300"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.17","ref":"firebase/storage-resize-images@0.1.17","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.17","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs10\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred type","type":"SELECT","description":"The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","options":[{"value":"jpg","label":"jpg"},{"value":"png","label":"png"},{"value":"webp","label":"webp"},{"value":"tiff","label":"tiff"},{"value":"false","label":"Do not convert"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred type: The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"b90cae92b70e9bf6e4eab4ee92d8ae1fadfd5466f1442abec2973ccff0e475ee","createTime":"2021-01-14T17:46:16.836237Z","id":"0.1.17","releaseNotes":"docs - Adds documentation that explains which content types are supported, and shows how to set content type explicitly (#534)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"200"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.18","ref":"firebase/storage-resize-images@0.1.18","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.18","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs10\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred type","type":"SELECT","description":"The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","options":[{"value":"jpg","label":"jpg"},{"value":"png","label":"png"},{"value":"webp","label":"webp"},{"value":"tiff","label":"tiff"},{"value":"false","label":"Do not convert"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n\n#### Configuration Parameters\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred type: The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"4b3d920bb9c035e1b94bd6ccb5901af956d8c2ec63b38d369f53d3941cbf9a90","createTime":"2021-02-11T23:35:52.318567Z","id":"0.1.18","releaseNotes":"fixed - fixed a bug that caused resized images to be named incorrectly if their file extension was capitalized (#549)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"200"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.19","ref":"firebase/storage-resize-images@0.1.19","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.19","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs10\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"false","label":"original"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n\n#### Configuration Parameters\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"85653802698bb12bd4d4090b8de56f5f807c15d000756870395ecfd4815ece66","createTime":"2021-03-04T17:50:05.876197Z","id":"0.1.19","releaseNotes":"feature - Adds support for converting to more than one image format (#579)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"500"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.21","ref":"firebase/storage-resize-images@0.1.21","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.21","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs10\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"false","label":"original"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"a7252a179c6a38ac80d10fbb932eabb7e922b627090a07b91babb9b0c9a57c0e","createTime":"2021-04-15T21:30:45.121285Z","id":"0.1.21","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"600"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.22","ref":"firebase/storage-resize-images@0.1.22","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.22","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"false","label":"original"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n\n#### Configuration Parameters\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"d19f44e0cd23c5ea45a2bba07e7390cfe27b967826a8d601b89412e1362a1ecb","createTime":"2021-06-17T18:04:05.400316Z","id":"0.1.22","releaseNotes":"feature - added Warsaw (europe-central2) location (#677)\n\nfeature - updated Cloud Functions runtime to Node.js 14 (#660)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"1300"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.23","ref":"firebase/storage-resize-images@0.1.23","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.23","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"false","label":"original"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"4bd7c2a4ea1dff1c17f73cb988158a53c4a30cce318ce2ec73fabbead5d30693","createTime":"2021-10-20T18:21:31.562784Z","id":"0.1.23","releaseNotes":"feature - add Taiwan and Singapore Cloud Function locations (#729)\n","listing":{"state":"APPROVED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.24","ref":"firebase/storage-resize-images@0.1.24","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.24","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"false","label":"original"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"d0d2709ca16a418e9750ab2fa924fcdc2de5d45dc91d281b3479995dbf1036bf","createTime":"2021-10-21T13:47:27.093269Z","id":"0.1.24","releaseNotes":"fixed - update package lock file to fix installation errors (#782)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"400"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.25","ref":"firebase/storage-resize-images@0.1.25","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.25","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"false","label":"original"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"d4eaafe5234bfc6dbb096a8ea35bb0d32ee8861cb95532d8dd3fa9d0a7239211","createTime":"2021-12-13T21:57:29.342985Z","id":"0.1.25","releaseNotes":"fixed - fix errors when resizing Samsung-encoded JPEGs\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"700"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.26","ref":"firebase/storage-resize-images@0.1.26","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.26","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"false","label":"original"}],"default":"false"},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- \n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"cc530d81657d24f53ae4da1415642169fa2f8f321cd6f8d540e2dffdf1b698dc","createTime":"2022-03-07T16:50:58.893124Z","id":"0.1.26","releaseNotes":"fixed - generate correct `package-lock.json` files after `lerna bootstrap` (#779)\n\nfixed - update resized metadata content disposition (#839)\n\nfeature - add WEBP and GIF animation (#875)\n\nfixed - update validate workflow to use node14\n\nfixed - fix samsung encoded jpg resizing\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"200"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.26-rc.1","ref":"firebase/storage-resize-images@0.1.26-rc.1","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.26-rc.1","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"false","label":"original"}],"default":"false"},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- \n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"a822632bbe7b33034ebab0c053b8735839c925f3d90db4cd0757d1b33de7aac0","createTime":"2022-03-02T21:28:30.026260Z","id":"0.1.26-rc.1","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.27","ref":"firebase/storage-resize-images@0.1.27","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.27","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"f35b38ba04316e2c1740d926d5e0600ab27162a3e72b39c30c7188015c523cda","createTime":"2022-04-07T18:48:34.715302Z","id":"0.1.27","releaseNotes":"fixed - update to firebase-admin v10 (#935)\n\nfeature - add output options param, to support [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg) (#878)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"200"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.28","ref":"firebase/storage-resize-images@0.1.28","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.28","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for all changes made to your specified Cloud Storage bucket, finds any images, and resizes them. Resized images are stored in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"181466310919029d32f2df067e30058ad456e9eac0bb145e5481b1359a5758fc","createTime":"2022-05-10T16:07:21.268515Z","id":"0.1.28","releaseNotes":"feature - added extension event for image resize completion (#967)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"800"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.29","ref":"firebase/storage-resize-images@0.1.29","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.29","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"53c3ef614c8aa474091fcd18c8d688a841d5f28433599a50036e0cfa1e47536b","createTime":"2022-08-09T22:14:28.416069Z","id":"0.1.29","releaseNotes":"fixed - add size to metadata\n\nfeature - add an option to make the resized images public\n\nfixed - updated sharp lib dependency for improved compression algorithm\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"400"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.3","ref":"firebase/storage-resize-images@0.1.3","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.3","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/releases","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Deployment location","type":"SELECT","description":"Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"(.)+\\.(.)+\\.(.)+","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following metadata, if present, from the original image to the resized image(s):\n\n- [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control)\n- [`Content-Disposition`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Disposition)\n- [`Content-Encoding`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Encoding)\n- [`Content-Language`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Language)\n- [`Content-Type`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type)\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nNote that if you configured the `Cache-Control header for resized images` param, the specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Deployment location: Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"7a1283da29e4e66e45b79a6bef975480a388100b15aeaabba13db31b6f71a8ea","createTime":"2019-11-21T19:21:08.486676552Z","id":"0.1.3","releaseNotes":"feature - Automatically copy the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can configure your extension to overwrite the Cache-Control value for the resized image(s).\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"800"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.30","ref":"firebase/storage-resize-images@0.1.30","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.30","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"64d49102709cb18e65b6d6896091f72cbbf7306a87f4077631b93126539b09ce","createTime":"2022-09-29T18:22:00.156454Z","id":"0.1.30","releaseNotes":"feature - include original image data in events\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"600"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.30-rc.0","ref":"firebase/storage-resize-images@0.1.30-rc.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.30-rc.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"3df443606881f0415ca85f956345a78b616295c7f82133b88f90795c8883dff3","createTime":"2022-09-28T15:32:54.115340Z","id":"0.1.30-rc.0","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.31","ref":"firebase/storage-resize-images@0.1.31","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.31","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"85bb47ae9d602a01516a67499aee1a078fc4af804468a76f0a69e682c3a5385f","createTime":"2022-11-21T18:51:58.619150Z","id":"0.1.31","releaseNotes":"feature - add AVIF codec support\n\nfeature - update IMG_BUCKET param type to selectResource\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"100"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.31-rc.0","ref":"firebase/storage-resize-images@0.1.31-rc.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.31-rc.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"595d4422e5660a03be6ffc1bc08f638aba4b4fe8c0e4b3fbedeeb3e19ea17fc4","createTime":"2022-11-16T09:50:49.612394Z","id":"0.1.31-rc.0","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.31-rc.1","ref":"firebase/storage-resize-images@0.1.31-rc.1","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.31-rc.1","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"a1b095524da27dea748bbc9922d935a9b85dcd27f53d2ab0a255faa8c405a5e1","createTime":"2022-11-16T13:55:57.517370Z","id":"0.1.31-rc.1","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.32","ref":"firebase/storage-resize-images@0.1.32","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.32","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"946f89a07cfc8d420128a0f6ed21f488ceff0bef00ddef013f3bd4d638402fa8","createTime":"2022-12-05T17:05:39.269479Z","id":"0.1.32","releaseNotes":"feature - added lifecycle event to resize existing images\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"200"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.32-rc.0","ref":"firebase/storage-resize-images@0.1.32-rc.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.32-rc.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"a733e12e0104994f88a8fa892a7f05b6adf8f1e72b1107e8c02d441760daa346","createTime":"2022-12-01T22:24:07.954720Z","id":"0.1.32-rc.0","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.33","ref":"firebase/storage-resize-images@0.1.33","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.33","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"2c70a453af018330671a8ca63af31676f8ef7ee9c58a9d452d7f3c0255ebaa13","createTime":"2023-01-06T09:15:59.836425Z","id":"0.1.33","releaseNotes":"fixed - re-add input object data to the complete event\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"300"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.33-rc.0","ref":"firebase/storage-resize-images@0.1.33-rc.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.33-rc.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"c00310215a913e01b8086863c8fcf7c54534a3a653b7a8c7da7472a955f828b2","createTime":"2023-01-05T17:17:39.571251Z","id":"0.1.33-rc.0","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.34","ref":"firebase/storage-resize-images@0.1.34","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.34","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"e4bebdc6c35b8b3920bed5fe5e9ced34d2b8709c16d9b658f9f7f8fa8bb0423d","createTime":"2023-02-08T12:01:49.735289Z","id":"0.1.34","releaseNotes":"feature - upgrade extensions to the latest firebase-admin sdk\n\nfixed - support backfill task in custom region\n\nfeature - add description to the failedImagesPath param\n\nfeature - put failed resizes in separate directory #563\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"400"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.34-rc.0","ref":"firebase/storage-resize-images@0.1.34-rc.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.34-rc.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"54cf6b24023875e0a0d064e948f01281daf8c7c7b6680fabb8c9c362f5fb2dd2","createTime":"2023-02-08T10:18:43.398137Z","id":"0.1.34-rc.0","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.35","ref":"firebase/storage-resize-images@0.1.35","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.35","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"7f12461bf80bc00b378332cd51d5375913e204ea006f5a04a435eacdfe0dfb54","createTime":"2023-03-17T16:20:20.728921Z","id":"0.1.35","releaseNotes":"feature - handle jfif extensions correctly\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"200"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.35-rc.0","ref":"firebase/storage-resize-images@0.1.35-rc.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.35-rc.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"84854e3f2b380279aae462fe08b6a0ee740ddcb45607109049e58bf31c8a7554","createTime":"2023-03-17T11:08:18.520029Z","id":"0.1.35-rc.0","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.35-rc.1","ref":"firebase/storage-resize-images@0.1.35-rc.1","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.35-rc.1","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"f6c273d14364e202c727054e3c53dbba4cc55c917ceabda58dd394a2036cb52c","createTime":"2023-03-17T15:51:54.538429Z","id":"0.1.35-rc.1","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.36","ref":"firebase/storage-resize-images@0.1.36","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.36","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"53459008c80d2746fca36a5c25ca94e3fb03a7b565f5299905a76c1ad0d3f823","createTime":"2023-04-05T14:33:20.703655Z","id":"0.1.36","releaseNotes":"fixed - added fixes for gcs vulnerabilities\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"700"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.36-rc.0","ref":"firebase/storage-resize-images@0.1.36-rc.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.36-rc.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"a299e65b763903d86e6480bc4cc2cef3ce470e8b69181d3d0a928458e51f3a3a","createTime":"2023-04-05T14:04:27.144128Z","id":"0.1.36-rc.0","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.37","ref":"firebase/storage-resize-images@0.1.37","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.37","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs16\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs16\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"008e9b78f75cc2082febea52eb76a3c2e17f90f23f90e7b0f5bdfe9a43aa6c81","createTime":"2023-06-07T17:38:42.485685Z","id":"0.1.37","releaseNotes":"feature - bump to nodejs16\n\nfixed - correct include path list description\n","buildSourceUri":"https://github.com/firebase/extensions/tree/25537363d0d4416fd5d9326a0d5f452fd6e342f3","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"600"},"extensionRoot":"storage-resize-images"},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.37-rc.0","ref":"firebase/storage-resize-images@0.1.37-rc.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.37-rc.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs16\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs16\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"2c7381c0a52c465ebfe5cf84ffe8c54a69e124fa4fd1f26f7df25c86bc4bc672","createTime":"2023-06-06T16:26:29.964259Z","id":"0.1.37-rc.0","buildSourceUri":"https://github.com/firebase/extensions/tree/56b4e9aa09971c65eca8e3e14065ca567e7b2e55","listing":{"state":"UNLISTED"},"extensionRoot":"storage-resize-images"},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.38","ref":"firebase/storage-resize-images@0.1.38","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.38","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nruntime: nodejs18\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nruntime: nodejs18\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true},{"param":"firebaseextensions.v1beta.function/location","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your database. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true}]},"state":"PUBLISHED","hash":"0192f0f7a558e821739b6ad0452247eabc19a9bef8091f04bcd2afe15b5b1294","createTime":"2023-07-12T08:31:00.938559Z","id":"0.1.38","releaseNotes":"feature - bump to node 18\n","buildSourceUri":"https://github.com/firebase/extensions/tree/8705822e3a07191d38fcfff9f5ab6878ce227823","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"100"},"extensionRoot":"storage-resize-images"},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.38-rc.0","ref":"firebase/storage-resize-images@0.1.38-rc.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.38-rc.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nruntime: nodejs18\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nruntime: nodejs18\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true},{"param":"firebaseextensions.v1beta.function/location","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your database. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true}]},"state":"PUBLISHED","hash":"f78fa62e5e4f6bb33e54e2bb8be8ae58811a6c20d69df7be9d9746d76c1fd1b8","createTime":"2023-07-11T15:44:50.964991Z","id":"0.1.38-rc.0","buildSourceUri":"https://github.com/firebase/extensions/tree/fb7db1eb9b83dd533711a491764732a57da7643e","listing":{"state":"UNLISTED"},"extensionRoot":"storage-resize-images"},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.4","ref":"firebase/storage-resize-images@0.1.4","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.4","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following metadata, if present, from the original image to the resized image(s):\n\n- [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control)\n- [`Content-Disposition`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Disposition)\n- [`Content-Encoding`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Encoding)\n- [`Content-Language`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Language)\n- [`Content-Type`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type)\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nNote that if you configured the `Cache-Control header for resized images` param, the specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"c86d57ccd6d5a684a218a3d8c3fd7ee981f8b6c265598a549a061efa2101077e","createTime":"2020-01-16T18:19:34.532055498Z","id":"0.1.4","releaseNotes":"fixed - Fixed bug where name of resized file was missing original name if there was no file extension. (issue #20)\n\nfixed - Fixed \"TypeError: Cannot set property 'resizedImage' of undefined\". (issue #130)\n\nfixed - Fixed bug where some valid bucket names were rejected during configuration. (issue #27)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"900"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.5","ref":"firebase/storage-resize-images@0.1.5","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.5","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"9596eaf7533fe73df3b7e449a862466048e25c8d83b1edcddc3db1947cd873ef","createTime":"2020-04-09T17:19:22.670451672Z","id":"0.1.5","releaseNotes":"fixed - The original, uploaded image's MIME type must now always be specified in the `Content-Type` header. (Issue #175)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"300"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.0-rc.1","ref":"firebase/storage-resize-images@0.1.0-rc.1","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores both images in the same Cloud Storage bucket.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://dev-partners.googlesource.com/samples/firebase/mods/+log","sourceUrl":"https://accounts.google.com/AccountChooser/signinchooser?service=gerritcodereview&continue=https%3A%2F%2Fdev-partners.googlesource.com%2Flogin%2Fsamples%2Ffirebase%2Fmods%2F%2B%2Fmaster%2Fstorage-resize-images","params":[{"param":"LOCATION","label":"Deployment location","type":"SELECT","description":"Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1"},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"(.)+\\.(.)+\\.(.)+","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-image).\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension creates a resized image with your specified dimensions. It stores both the resized image and the original image in the same Storage bucket. The extension names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height. For example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket. Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension creates resized image(s) with your specfied dimensions. It stores both the resized image(s) and the original image in the same bucket, `${param:IMG_BUCKET}`. The extension names a resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# storage-resize-images\n\n**VERSION**: 0.1.0\n\n**DESCRIPTION**: Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.\n\n\n\n**CONFIGURATION PARAMETERS:**\n\n* Deployment location: *Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).*\n\n* Cloud Storage bucket for images: *To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n*\n\n* Sizes of resized images: *What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n*\n\n* Cloud Storage path for resized images: *A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-image).\n*\n\n* Cache-Control header for resized images: *Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n*\n\n\n\n**NON-CLOUD FUNCTION RESOURCES CREATED**:\n\n* generateResizedImage (firebaseextensions.v1beta.function)\n\n\n\n**DETAILS**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension creates a resized image with your specified dimensions. It stores both the resized image and the original image in the same Storage bucket. The extension names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height. For example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n**APIS USED**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**ACCESS REQUIRED**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","createTime":"2019-09-12T20:31:32.735300678Z","id":"0.1.0-rc.1","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.0-rc.2","ref":"firebase/storage-resize-images@0.1.0-rc.2","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores both images in the same Cloud Storage bucket.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/commits/master","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Deployment location","type":"SELECT","description":"Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1"},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"(.)+\\.(.)+\\.(.)+","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-image).\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n- Creates resized image(s) with your specfied dimensions.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# storage-resize-images\n\n**VERSION**: 0.1.0\n\n**DESCRIPTION**: Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.\n\n\n\n**CONFIGURATION PARAMETERS:**\n\n* Deployment location: Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-image).\n\n\n* Cache-Control header for resized images: Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n\n\n\n\n**CLOUD FUNCTIONS CREATED:**\n\n* generateResizedImage (google.storage.object.finalize)\n\n\n\n**DETAILS**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n**APIS USED**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**ACCESS REQUIRED**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","createTime":"2019-09-18T16:45:41.559534413Z","id":"0.1.0-rc.2","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.1-rc.1","ref":"firebase/storage-resize-images@0.1.1-rc.1","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.1","description":"Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores both images in the same Cloud Storage bucket.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/commits/master","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Deployment location","type":"SELECT","description":"Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1"},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"(.)+\\.(.)+\\.(.)+","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-image).\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n\n- Creates resized image(s) with your specfied dimensions.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# storage-resize-images\n\n**VERSION**: 0.1.0\n\n**DESCRIPTION**: Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.\n\n\n\n**CONFIGURATION PARAMETERS:**\n\n* Deployment location: Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-image).\n\n\n* Cache-Control header for resized images: Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n\n\n\n\n**CLOUD FUNCTIONS CREATED:**\n\n* generateResizedImage (google.storage.object.finalize)\n\n\n\n**DETAILS**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n**APIS USED**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**ACCESS REQUIRED**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","createTime":"2019-10-14T19:00:02.187428910Z","id":"0.1.1-rc.1","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.1-rc.2","ref":"firebase/storage-resize-images@0.1.1-rc.2","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.1","description":"Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores both images in the same Cloud Storage bucket.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/releases","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Deployment location","type":"SELECT","description":"Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1"},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"(.)+\\.(.)+\\.(.)+","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n\n- Creates resized image(s) with your specfied dimensions.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# storage-resize-images\n\n**VERSION**: 0.1.0\n\n**DESCRIPTION**: Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.\n\n\n\n**CONFIGURATION PARAMETERS:**\n\n* Deployment location: Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-image).\n\n\n* Cache-Control header for resized images: Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n\n\n\n\n**CLOUD FUNCTIONS CREATED:**\n\n* generateResizedImage (google.storage.object.finalize)\n\n\n\n**DETAILS**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n**APIS USED**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**ACCESS REQUIRED**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","createTime":"2019-10-15T22:49:45.589434762Z","id":"0.1.1-rc.2","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.16-rc.1","ref":"firebase/storage-resize-images@0.1.16-rc.1","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.16","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs10\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred type","type":"SELECT","description":"The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","options":[{"value":"jpg","label":"jpg"},{"value":"png","label":"png"},{"value":"webp","label":"webp"},{"value":"tiff","label":"tiff"},{"value":"false","label":"Do not convert"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred type: The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","createTime":"2020-12-03T20:37:21.202540Z","id":"0.1.16-rc.1","listing":{"state":"UNLISTED"},"metrics":{"activeInstallCount":"80"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.4-rc.1","ref":"firebase/storage-resize-images@0.1.4-rc.1","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.4","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Deployment location","type":"SELECT","description":"Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following metadata, if present, from the original image to the resized image(s):\n\n- [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control)\n- [`Content-Disposition`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Disposition)\n- [`Content-Encoding`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Encoding)\n- [`Content-Language`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Language)\n- [`Content-Type`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type)\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nNote that if you configured the `Cache-Control header for resized images` param, the specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Deployment location: Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","createTime":"2020-01-09T18:10:50.007899289Z","id":"0.1.4-rc.1","listing":{"state":"UNLISTED"},"metrics":{"activeInstallCount":"100"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.5-rc.1","ref":"firebase/storage-resize-images@0.1.5-rc.1","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.5","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following metadata, if present, from the original image to the resized image(s):\n\n- [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control)\n- [`Content-Disposition`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Disposition)\n- [`Content-Encoding`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Encoding)\n- [`Content-Language`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Language)\n- [`Content-Type`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type)\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","createTime":"2020-03-05T18:15:20.965699655Z","id":"0.1.5-rc.1","listing":{"state":"UNLISTED"},"metrics":{"activeInstallCount":"200"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.6","ref":"firebase/storage-resize-images@0.1.6","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.6","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"fc1ff54f6d77722ecd86cbe9fcfc69be618a23bee4e58dee48bba844d839df84","createTime":"2020-04-23T17:17:59.966539870Z","id":"0.1.6","releaseNotes":"fixed - Switched ImageMagick for Sharp library to support webp format. (Issue #199)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"300"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.7","ref":"firebase/storage-resize-images@0.1.7","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.7","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"eb333fcdfff9795fb1cd02ae737493270721fc44068b8a1983a0aa20479f132b","createTime":"2020-05-07T17:13:51.872987459Z","id":"0.1.7","releaseNotes":"fixed - Resized images now render in the Firebase console. (Issue #140)\n\nfixed - The Sharp cache is now cleared so that the latest image with a given\nfile name is retrieved from the Storage bucket. (Issue #286)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"300"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.8","ref":"firebase/storage-resize-images@0.1.8","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.8","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"b02ebe65202c3535bad8e69daf46767be76102858277af1bc33654e588acc5e7","createTime":"2020-05-20T17:55:21.556770994Z","id":"0.1.8","releaseNotes":"fixed - Resized images now maintain the same orientation as the original image. (Issue #290)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"500"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.9","ref":"firebase/storage-resize-images@0.1.9","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.9","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"a139bcfefbf19e901b67789105a3841ed208c6e449a896bafcc4a01e43c07844","createTime":"2020-06-11T18:12:20.333403Z","id":"0.1.9","releaseNotes":"changed - If the original image is a vector image, the extension does not resize it. (Issue #326, PR #329)\n\nfixed - Replaced `mkdirp-promise` with `mkdirp` because `mkdirp-promise` is deprecated. (PR #266)\n\nfixed - If the original image is smaller than the specified max width and height, the extension does not enlarge it or resize it. (Issue #337, PR #338)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"300"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.5-rc.2","ref":"firebase/storage-resize-images@0.1.5-rc.2","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.5","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following metadata, if present, from the original image to the resized image(s):\n\n- [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control)\n- [`Content-Disposition`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Disposition)\n- [`Content-Encoding`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Encoding)\n- [`Content-Language`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Language)\n- [`Content-Type`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type)\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","createTime":"2020-03-19T18:14:15.960944126Z","id":"0.1.5-rc.2","listing":{"state":"UNLISTED"},"metrics":{"activeInstallCount":"500"}}]}
[debug] [2023-07-18T14:47:12.258Z] >>> [apiv2][query] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images/versions/0.1.37 [none]
[debug] [2023-07-18T14:47:12.936Z] <<< [apiv2][status] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images/versions/0.1.37 200
[debug] [2023-07-18T14:47:12.936Z] <<< [apiv2][body] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images/versions/0.1.37 {"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.37","ref":"firebase/storage-resize-images@0.1.37","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.37","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs16\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs16\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"008e9b78f75cc2082febea52eb76a3c2e17f90f23f90e7b0f5bdfe9a43aa6c81","createTime":"2023-06-07T17:38:42.485685Z","sourceDownloadUri":"https://storage.googleapis.com/firebase-mod-sources-prod/008e9b78f75cc2082febea52eb76a3c2e17f90f23f90e7b0f5bdfe9a43aa6c81","id":"0.1.37","releaseNotes":"feature - bump to nodejs16\n\nfixed - correct include path list description\n","buildSourceUri":"https://github.com/firebase/extensions/tree/25537363d0d4416fd5d9326a0d5f452fd6e342f3","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"600"},"extensionRoot":"storage-resize-images"}
[debug] [2023-07-18T14:47:12.942Z] [extensions] Source code valid for firebase/storage-resize-images@0.1.37
[warn] ⚠  Function 'backfillResizedImages is missing a trigger in extension.yaml. Please add one, as triggers defined in code are ignored. {"metadata":{"emulator":{"name":"functions"},"message":"Function 'backfillResizedImages is missing a trigger in extension.yaml. Please add one, as triggers defined in code are ignored."}}
[debug] [2023-07-18T14:47:12.952Z] >>> [apiv2][query] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images [none]
[debug] [2023-07-18T14:47:13.598Z] <<< [apiv2][status] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images 200
[debug] [2023-07-18T14:47:13.598Z] <<< [apiv2][body] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images {"name":"publishers/firebase/extensions/storage-resize-images","ref":"firebase/storage-resize-images","latestVersion":"0.1.38","latestVersionCreateTime":"2023-07-12T08:31:00.938559Z","state":"PUBLISHED","createTime":"2021-03-18T22:07:59.572345Z","iconUri":"https://storage.googleapis.com/firebase-extensions-icons/extension_icons/firebase/resize_images_120@2x.png","publisher":{"displayName":"Firebase","iconUri":"https://storage.googleapis.com/firebase-extensions-icons/publisher_icons/firebase/firebase_128dp.png"},"repoUri":"https://github.com/firebase/extensions","metrics":{"activeInstallCount":"18600"},"latestApprovedVersion":"0.1.38"}
[debug] [2023-07-18T14:47:13.612Z] [functions] Functions Emulator only supports listening on one address (127.0.0.1). Not listening on ::1
[debug] [2023-07-18T14:47:13.612Z] [eventarc] Eventarc Emulator only supports listening on one address (127.0.0.1). Not listening on ::1
[debug] [2023-07-18T14:47:13.612Z] [logging] Logging Emulator only supports listening on one address (127.0.0.1). Not listening on ::1
[debug] [2023-07-18T14:47:13.612Z] assigned listening specs for emulators {"user":{"ui":[{"address":"127.0.0.1","family":"IPv4","port":4000}],"auth":[{"address":"127.0.0.1","family":"IPv4","port":9099}],"firestore":[{"address":"127.0.0.1","family":"IPv4","port":8080}],"firestore.websocket":[{"address":"127.0.0.1","family":"IPv4","port":9150}],"storage":[{"address":"127.0.0.1","family":"IPv4","port":9199}],"functions":[{"address":"127.0.0.1","family":"IPv4","port":5001}],"eventarc":[{"address":"127.0.0.1","family":"IPv4","port":9299}],"hub":[{"address":"127.0.0.1","family":"IPv4","port":4400},{"address":"::1","family":"IPv6","port":4400}],"logging":[{"address":"127.0.0.1","family":"IPv4","port":4500}]},"metadata":{"message":"assigned listening specs for emulators"}}
[debug] [2023-07-18T14:47:13.644Z] [hub] writing locator at /tmp/hub-birch-collective-develop.json
[debug] [2023-07-18T14:47:13.648Z] [Extensions] Started Extensions emulator, this is a noop.
[warn] ⚠  functions: The following emulators are not running, calls to these services from the Functions emulator will affect production: database, hosting, pubsub {"metadata":{"emulator":{"name":"functions"},"message":"The following emulators are not running, calls to these services from the Functions emulator will affect production: \u001b[1mdatabase, hosting, pubsub\u001b[22m"}}
[debug] [2023-07-18T14:47:13.650Z] defaultcredentials: writing to file /home/ruben/.config/firebase/a_ruben00001_gmail.com_application_default_credentials.json
[debug] [2023-07-18T14:47:13.662Z] Setting GAC to /home/ruben/.config/firebase/a_ruben00001_gmail.com_application_default_credentials.json {"metadata":{"emulator":{"name":"functions"},"message":"Setting GAC to /home/ruben/.config/firebase/a_ruben00001_gmail.com_application_default_credentials.json"}}
[debug] [2023-07-18T14:47:13.662Z] >>> [apiv2][query] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop/adminSdkConfig [none]
[debug] [2023-07-18T14:47:13.870Z] <<< [apiv2][status] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop/adminSdkConfig 200
[debug] [2023-07-18T14:47:13.870Z] <<< [apiv2][body] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop/adminSdkConfig {"projectId":"birch-collective-develop","storageBucket":"birch-collective-develop.appspot.com","locationId":"europe-west2"}
[info] i  firestore: Importing data from /home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/db-local-data/firestore_export/firestore_export.overall_export_metadata {"metadata":{"emulator":{"name":"firestore"},"message":"Importing data from /home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/db-local-data/firestore_export/firestore_export.overall_export_metadata"}}
[debug] [2023-07-18T14:47:13.904Z] Ignoring unsupported arg: auto_download {"metadata":{"emulator":{"name":"firestore"},"message":"Ignoring unsupported arg: auto_download"}}
[debug] [2023-07-18T14:47:13.905Z] Ignoring unsupported arg: single_project_mode_error {"metadata":{"emulator":{"name":"firestore"},"message":"Ignoring unsupported arg: single_project_mode_error"}}
[debug] [2023-07-18T14:47:13.905Z] Starting Firestore Emulator with command {"binary":"java","args":["-Dgoogle.cloud_firestore.debug_log_level=FINE","-Duser.language=en","-jar","/home/ruben/.cache/firebase/emulators/cloud-firestore-emulator-v1.17.4.jar","--host","127.0.0.1","--port",8080,"--websocket_port",9150,"--project_id","birch-collective-develop","--seed_from_export","/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/db-local-data/firestore_export/firestore_export.overall_export_metadata","--rules","/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/firestore.rules","--single_project_mode",true,"--functions_emulator","127.0.0.1:5001"],"optionalArgs":["port","webchannel_port","host","rules","websocket_port","functions_emulator","seed_from_export","project_id","single_project_mode"],"joinArgs":false} {"metadata":{"emulator":{"name":"firestore"},"message":"Starting Firestore Emulator with command {\"binary\":\"java\",\"args\":[\"-Dgoogle.cloud_firestore.debug_log_level=FINE\",\"-Duser.language=en\",\"-jar\",\"/home/ruben/.cache/firebase/emulators/cloud-firestore-emulator-v1.17.4.jar\",\"--host\",\"127.0.0.1\",\"--port\",8080,\"--websocket_port\",9150,\"--project_id\",\"birch-collective-develop\",\"--seed_from_export\",\"/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/db-local-data/firestore_export/firestore_export.overall_export_metadata\",\"--rules\",\"/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/firestore.rules\",\"--single_project_mode\",true,\"--functions_emulator\",\"127.0.0.1:5001\"],\"optionalArgs\":[\"port\",\"webchannel_port\",\"host\",\"rules\",\"websocket_port\",\"functions_emulator\",\"seed_from_export\",\"project_id\",\"single_project_mode\"],\"joinArgs\":false}"}}
[info] i  firestore: Firestore Emulator logging to firestore-debug.log {"metadata":{"emulator":{"name":"firestore"},"message":"Firestore Emulator logging to \u001b[1mfirestore-debug.log\u001b[22m"}}
[debug] [2023-07-18T14:47:16.794Z] Jul 18, 2023 3:47:16 PM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketServer start
INFO: Started WebSocket server on ws://127.0.0.1:9150
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:47:16 PM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketServer start\nINFO: Started WebSocket server on ws://127.0.0.1:9150\n"}}
[debug] [2023-07-18T14:47:16.860Z] API endpoint: http://127.0.0.1:8080
If you are using a library that supports the FIRESTORE_EMULATOR_HOST environment variable, run:

   export FIRESTORE_EMULATOR_HOST=127.0.0.1:8080

Dev App Server is now running.

 {"metadata":{"emulator":{"name":"firestore"},"message":"API endpoint: http://127.0.0.1:8080\nIf you are using a library that supports the FIRESTORE_EMULATOR_HOST environment variable, run:\n\n   export FIRESTORE_EMULATOR_HOST=127.0.0.1:8080\n\nDev App Server is now running.\n\n"}}
[info] ✔  firestore: Firestore Emulator UI websocket is running on 9150. {"metadata":{"emulator":{"name":"firestore"},"message":"Firestore Emulator UI websocket is running on 9150."}}
[info] i  auth: Importing config from /home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/db-local-data/auth_export/config.json {"metadata":{"emulator":{"name":"auth"},"message":"Importing config from /home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/db-local-data/auth_export/config.json"}}
[info] i  auth: Importing accounts from /home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/db-local-data/auth_export/accounts.json {"metadata":{"emulator":{"name":"auth"},"message":"Importing accounts from /home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/db-local-data/auth_export/accounts.json"}}
[debug] [2023-07-18T14:47:28.105Z] Ignoring unsupported arg: port {"metadata":{"emulator":{"name":"storage"},"message":"Ignoring unsupported arg: port"}}
[debug] [2023-07-18T14:47:29.307Z] Temp file directory for storage emulator: /tmp/firebase/storage/blobs {"metadata":{"emulator":{"name":"storage"},"message":"Temp file directory for storage emulator: /tmp/firebase/storage/blobs"}}
[debug] [2023-07-18T14:47:29.332Z] Ignoring unsupported arg: auto_download {"metadata":{"emulator":{"name":"ui"},"message":"Ignoring unsupported arg: auto_download"}}
[debug] [2023-07-18T14:47:29.333Z] Ignoring unsupported arg: port {"metadata":{"emulator":{"name":"ui"},"message":"Ignoring unsupported arg: port"}}
[debug] [2023-07-18T14:47:29.333Z] Starting Emulator UI with command {"binary":"node","args":["/home/ruben/.cache/firebase/emulators/ui-v1.11.6/server/server.js"],"optionalArgs":[],"joinArgs":false} {"metadata":{"emulator":{"name":"ui"},"message":"Starting Emulator UI with command {\"binary\":\"node\",\"args\":[\"/home/ruben/.cache/firebase/emulators/ui-v1.11.6/server/server.js\"],\"optionalArgs\":[],\"joinArgs\":false}"}}
[info] i  ui: Emulator UI logging to ui-debug.log {"metadata":{"emulator":{"name":"ui"},"message":"Emulator UI logging to \u001b[1mui-debug.log\u001b[22m"}}
[debug] [2023-07-18T14:47:29.458Z] Web / API server started at 127.0.0.1:4000
 {"metadata":{"emulator":{"name":"ui"},"message":"Web / API server started at 127.0.0.1:4000\n"}}
[debug] [2023-07-18T14:47:29.602Z] [Extensions] Connecting Extensions emulator, this is a noop.
[info] i  functions: Watching "/home/ruben/.cache/firebase/extensions/firebase/storage-resize-images@0.1.37/functions" for Cloud Functions... {"metadata":{"emulator":{"name":"functions"},"message":"Watching \"/home/ruben/.cache/firebase/extensions/firebase/storage-resize-images@0.1.37/functions\" for Cloud Functions..."}}
[info] ✔  functions: Loaded functions definitions from source: generateResizedImage, backfillResizedImages. {"metadata":{"emulator":{"name":"functions"},"message":"Loaded functions definitions from source: generateResizedImage, backfillResizedImages."}}
[debug] [2023-07-18T14:47:29.608Z] addStorageTrigger {"eventTrigger":{"eventType":"google.storage.object.finalize","resource":"projects/_/buckets/birch-collective-develop.appspot.com","service":"storage.googleapis.com"}}
[info] ✔  functions[europe-west2-ext-storage-resize-images-generateResizedImage]: storage function initialized. {"metadata":{"emulator":{"name":"functions"},"message":"\u001b[1mstorage\u001b[22m function initialized."}}
[warn] ⚠  Unsupported function type on ext-storage-resize-images-backfillResizedImages. Expected either an httpsTrigger, eventTrigger, or blockingTrigger. {"metadata":{"emulator":{"name":"functions"},"message":"Unsupported function type on ext-storage-resize-images-backfillResizedImages. Expected either an httpsTrigger, eventTrigger, or blockingTrigger."}}
[info] i  functions[europe-west2-ext-storage-resize-images-backfillResizedImages]: function ignored because the unknown emulator does not exist or is not running. {"metadata":{"emulator":{"name":"functions"},"message":"function ignored because the unknown emulator does not exist or is not running."}}
[info] i  functions: Watching "/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/functions" for Cloud Functions... {"metadata":{"emulator":{"name":"functions"},"message":"Watching \"/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/functions\" for Cloud Functions..."}}
[debug] [2023-07-18T14:47:29.632Z] Validating nodejs source
[debug] [2023-07-18T14:47:30.927Z] > [functions] package.json contents: {
  "name": "functions",
  "description": "Cloud Functions for Firebase",
  "scripts": {
    "serve": "firebase emulators:start --only functions",
    "shell": "firebase functions:shell",
    "start": "npm run shell",
    "deploy": "firebase deploy --only functions",
    "logs": "firebase functions:log"
  },
  "engines": {
    "node": "18"
  },
  "main": "index.js",
  "dependencies": {
    "firebase-admin": "^11.8.0",
    "firebase-functions": "^4.3.1"
  },
  "devDependencies": {
    "firebase-functions-test": "^3.1.0"
  },
  "private": true
}
[debug] [2023-07-18T14:47:30.928Z] Building nodejs source
[debug] [2023-07-18T14:47:30.928Z] Failed to find version of module node: reached end of search path /home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/functions/node_modules
[info] ✔  functions: Using node@18 from host. 
[debug] [2023-07-18T14:47:30.931Z] Could not find functions.yaml. Must use http discovery
[debug] [2023-07-18T14:47:30.937Z] Found firebase-functions binary at '/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/functions/node_modules/.bin/firebase-functions'
[debug] [2023-07-18T14:47:31.212Z] Serving at port 8267

[debug] [2023-07-18T14:47:31.395Z] Got response from /__/functions.yaml {"endpoints":{},"specVersion":"v1alpha1","requiredAPIs":[]}
[debug] [2023-07-18T14:47:31.404Z] shutdown requested via /__/quitquitquit

[info] ✔  functions: Loaded functions definitions from source: . {"metadata":{"emulator":{"name":"functions"},"message":"Loaded functions definitions from source: ."}}
[info] 
┌─────────────────────────────────────────────────────────────┐
│ ✔  All emulators ready! It is now safe to connect your app. │
│ i  View Emulator UI at http://127.0.0.1:4000/               │
└─────────────────────────────────────────────────────────────┘

┌────────────────┬────────────────┬──────────────────────────────────┐
│ Emulator       │ Host:Port      │ View in Emulator UI              │
├────────────────┼────────────────┼──────────────────────────────────┤
│ Authentication │ 127.0.0.1:9099 │ http://127.0.0.1:4000/auth       │
├────────────────┼────────────────┼──────────────────────────────────┤
│ Functions      │ 127.0.0.1:5001 │ http://127.0.0.1:4000/functions  │
├────────────────┼────────────────┼──────────────────────────────────┤
│ Firestore      │ 127.0.0.1:8080 │ http://127.0.0.1:4000/firestore  │
├────────────────┼────────────────┼──────────────────────────────────┤
│ Storage        │ 127.0.0.1:9199 │ http://127.0.0.1:4000/storage    │
├────────────────┼────────────────┼──────────────────────────────────┤
│ Extensions     │ 127.0.0.1:5001 │ http://127.0.0.1:4000/extensions │
└────────────────┴────────────────┴──────────────────────────────────┘
  Emulator Hub running at 127.0.0.1:4400
  Other reserved ports: 4500, 9150
┌─────────────────────────┬───────────────────────────────────────┬────────────────────────────────────────────────────────┐
│ Extension Instance Name │ Extension Ref                         │ View in Emulator UI                                    │
├─────────────────────────┼───────────────────────────────────────┼────────────────────────────────────────────────────────┤
│ storage-resize-images   │ firebase/storage-resize-images@0.1.37 │ http://127.0.0.1:4000/extensions/storage-resize-images │
└─────────────────────────┴───────────────────────────────────────┴────────────────────────────────────────────────────────┘
Issues? Report them at https://github.com/firebase/firebase-tools/issues and attach the *-debug.log files.
 
[debug] [2023-07-18T14:47:31.923Z] Jul 18, 2023 3:47:31 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:47:31 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:47:31.924Z] Jul 18, 2023 3:47:31 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:47:31 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:47:32.127Z] Jul 18, 2023 3:47:32 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:47:32 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:47:33.879Z] Jul 18, 2023 3:47:33 PM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketChannelHandler initChannel
INFO: Connected to new websocket client
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:47:33 PM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketChannelHandler initChannel\nINFO: Connected to new websocket client\n"}}
[debug] [2023-07-18T14:47:33.953Z] Jul 18, 2023 3:47:33 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:47:33 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:47:34.069Z] Jul 18, 2023 3:47:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:47:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:47:34.262Z] Jul 18, 2023 3:47:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:47:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:47:34.367Z] Jul 18, 2023 3:47:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:47:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:47:36.555Z] Jul 18, 2023 3:47:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:47:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:47:36.639Z] Jul 18, 2023 3:47:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:47:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:47:37.906Z] Jul 18, 2023 3:47:37 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:47:37 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:47:37.976Z] Jul 18, 2023 3:47:37 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:47:37 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:47:38.684Z] Jul 18, 2023 3:47:38 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:47:38 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:48:35.626Z] Jul 18, 2023 3:48:35 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:48:35 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:48:53.748Z] Jul 18, 2023 3:48:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:48:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:49:00.499Z] Jul 18, 2023 3:49:00 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:49:00 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:49:00.547Z] Jul 18, 2023 3:49:00 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:49:00 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:49:00.555Z] Jul 18, 2023 3:49:00 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:49:00 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:49:33.764Z] Jul 18, 2023 3:49:33 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:49:33 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:49:58.001Z] Jul 18, 2023 3:49:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:49:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:49:58.036Z] Jul 18, 2023 3:49:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:49:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:49:58.036Z] Jul 18, 2023 3:49:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:49:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:50:10.811Z] Jul 18, 2023 3:50:10 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:50:10 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:50:10.858Z] Jul 18, 2023 3:50:10 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:50:10 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:50:10.860Z] Jul 18, 2023 3:50:10 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 18, 2023 3:50:10 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:50:10 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 18, 2023 3:50:10 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:50:10.861Z] Jul 18, 2023 3:50:10 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:50:10 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:50:19.117Z] Jul 18, 2023 3:50:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:50:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:50:49.180Z] Jul 18, 2023 3:50:49 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:50:49 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:51:05.117Z] Jul 18, 2023 3:51:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:51:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:51:20.121Z] Jul 18, 2023 3:51:20 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:51:20 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:51:20.125Z] Jul 18, 2023 3:51:20 PM com.google.cloud.datastore.emulator.firestore.webchannel.FirestoreV1WebChannelAdapter$FirestoreWriteHandler onClose
INFO: channel closed
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:51:20 PM com.google.cloud.datastore.emulator.firestore.webchannel.FirestoreV1WebChannelAdapter$FirestoreWriteHandler onClose\nINFO: channel closed\n"}}
[debug] [2023-07-18T14:52:21.095Z] Jul 18, 2023 3:52:21 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:52:21 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:53:07.095Z] Jul 18, 2023 3:53:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:53:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:54:23.097Z] Jul 18, 2023 3:54:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:54:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:55:23.138Z] Jul 18, 2023 3:55:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:55:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:56:09.094Z] Jul 18, 2023 3:56:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:56:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:56:55.095Z] Jul 18, 2023 3:56:55 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:56:55 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:58:11.099Z] Jul 18, 2023 3:58:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:58:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:59:27.099Z] Jul 18, 2023 3:59:27 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:59:27 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T14:59:29.351Z] Jul 18, 2023 3:59:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 3:59:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:00:43.100Z] Jul 18, 2023 4:00:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:00:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:01:29.096Z] Jul 18, 2023 4:01:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:01:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:02:29.131Z] Jul 18, 2023 4:02:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:02:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:03:45.098Z] Jul 18, 2023 4:03:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:03:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:05:01.094Z] Jul 18, 2023 4:05:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:05:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:05:47.100Z] Jul 18, 2023 4:05:47 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:05:47 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:07:03.095Z] Jul 18, 2023 4:07:03 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:07:03 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:07:45.726Z] Jul 18, 2023 4:07:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:07:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:07:45.726Z] Jul 18, 2023 4:07:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:07:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:08:03.107Z] Jul 18, 2023 4:08:03 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:08:03 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:09:19.101Z] Jul 18, 2023 4:09:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:09:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:10:35.099Z] Jul 18, 2023 4:10:35 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:10:35 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:11:21.094Z] Jul 18, 2023 4:11:21 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:11:21 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:12:21.109Z] Jul 18, 2023 4:12:21 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:12:21 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:13:37.103Z] Jul 18, 2023 4:13:37 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:13:37 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:14:53.099Z] Jul 18, 2023 4:14:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:14:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:16:09.094Z] Jul 18, 2023 4:16:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:16:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:16:55.099Z] Jul 18, 2023 4:16:55 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:16:55 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:18:11.097Z] Jul 18, 2023 4:18:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:18:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:19:11.113Z] Jul 18, 2023 4:19:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:19:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:19:57.099Z] Jul 18, 2023 4:19:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:19:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:20:57.116Z] Jul 18, 2023 4:20:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:20:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:22:13.098Z] Jul 18, 2023 4:22:13 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:22:13 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:23:29.096Z] Jul 18, 2023 4:23:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:23:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:24:45.098Z] Jul 18, 2023 4:24:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:24:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:25:45.124Z] Jul 18, 2023 4:25:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:25:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:26:45.145Z] Jul 18, 2023 4:26:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:26:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:27:45.178Z] Jul 18, 2023 4:27:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:27:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:29:01.098Z] Jul 18, 2023 4:29:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:29:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:30:17.098Z] Jul 18, 2023 4:30:17 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:30:17 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:31:03.098Z] Jul 18, 2023 4:31:03 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:31:03 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:31:49.099Z] Jul 18, 2023 4:31:49 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:31:49 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:33:05.099Z] Jul 18, 2023 4:33:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:33:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:34:21.098Z] Jul 18, 2023 4:34:21 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:34:21 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:35:37.098Z] Jul 18, 2023 4:35:37 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:35:37 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:36:53.099Z] Jul 18, 2023 4:36:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:36:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:38:09.111Z] Jul 18, 2023 4:38:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:38:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:39:25.099Z] Jul 18, 2023 4:39:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:39:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:40:25.120Z] Jul 18, 2023 4:40:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:40:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:41:41.098Z] Jul 18, 2023 4:41:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:41:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:42:41.118Z] Jul 18, 2023 4:42:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:42:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:43:57.099Z] Jul 18, 2023 4:43:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:43:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:44:57.119Z] Jul 18, 2023 4:44:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:44:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:46:13.098Z] Jul 18, 2023 4:46:13 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:46:13 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:46:59.099Z] Jul 18, 2023 4:46:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:46:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:47:50.956Z] Jul 18, 2023 4:47:50 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:47:50 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:47:50.968Z] Jul 18, 2023 4:47:50 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:47:50 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:47:50.969Z] Jul 18, 2023 4:47:50 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:47:50 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:48:15.096Z] Jul 18, 2023 4:48:15 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:48:15 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:49:15.113Z] Jul 18, 2023 4:49:15 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:49:15 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:50:01.094Z] Jul 18, 2023 4:50:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:50:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:50:47.098Z] Jul 18, 2023 4:50:47 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:50:47 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:51:33.095Z] Jul 18, 2023 4:51:33 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:51:33 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:52:19.094Z] Jul 18, 2023 4:52:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:52:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:53:05.101Z] Jul 18, 2023 4:53:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:53:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:54:05.123Z] Jul 18, 2023 4:54:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:54:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:54:51.094Z] Jul 18, 2023 4:54:51 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:54:51 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:54:58.740Z] Jul 18, 2023 4:54:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:54:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:54:58.756Z] Jul 18, 2023 4:54:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 18, 2023 4:54:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:54:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 18, 2023 4:54:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:56:07.095Z] Jul 18, 2023 4:56:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:56:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:57:23.096Z] Jul 18, 2023 4:57:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:57:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:58:23.115Z] Jul 18, 2023 4:58:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:58:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:59:09.100Z] Jul 18, 2023 4:59:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:59:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T15:59:55.099Z] Jul 18, 2023 4:59:55 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 4:59:55 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T16:00:32.004Z] Jul 18, 2023 5:00:32 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 5:00:32 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T16:00:32.024Z] Jul 18, 2023 5:00:32 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 5:00:32 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T16:00:41.099Z] Jul 18, 2023 5:00:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 5:00:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T16:01:57.098Z] Jul 18, 2023 5:01:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 5:01:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T16:03:07.531Z] Jul 18, 2023 5:03:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 5:03:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T16:04:07.550Z] Jul 18, 2023 5:04:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 5:04:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T16:05:23.095Z] Jul 18, 2023 5:05:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 5:05:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T16:06:09.100Z] Jul 18, 2023 5:06:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 5:06:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T16:07:09.122Z] Jul 18, 2023 5:07:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 5:07:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T16:07:55.094Z] Jul 18, 2023 5:07:55 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 5:07:55 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T16:08:41.100Z] Jul 18, 2023 5:08:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 5:08:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T16:09:41.113Z] Jul 18, 2023 5:09:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 5:09:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T16:10:27.106Z] Jul 18, 2023 5:10:27 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 5:10:27 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T16:11:43.100Z] Jul 18, 2023 5:11:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 5:11:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T16:12:59.103Z] Jul 18, 2023 5:12:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 5:12:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T16:13:59.123Z] Jul 18, 2023 5:13:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 5:13:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T16:14:45.096Z] Jul 18, 2023 5:14:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 5:14:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-18T16:14:58.130Z] Jul 18, 2023 5:14:58 PM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketChannelHandler channelClosed
INFO: Websocket client disconnected
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 18, 2023 5:14:58 PM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketChannelHandler channelClosed\nINFO: Websocket client disconnected\n"}}
[debug] [2023-07-18T16:14:59.585Z] Received signal SIGHUP 1
[info]  
[info] i  emulators: Received SIGHUP for the first time. Starting a clean shutdown. 
[info] i  emulators: Please wait for a clean shutdown or send the SIGHUP signal again to stop right now. 
[info] i  Automatically exporting data using --export-on-exit "./db-local-data" please wait for the export to finish... 
[debug] [2023-07-18T16:14:59.602Z] >>> [apiv2][query] GET http://127.0.0.1:4400/ [none]
[debug] [2023-07-18T16:14:59.617Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.618Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.619Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.619Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.620Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.620Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.620Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.621Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.621Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.622Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.622Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.623Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.627Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.628Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.629Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.629Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.629Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.630Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.631Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.633Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.634Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.635Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.636Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.636Z] Ignoring signal SIGHUP due to short delay of 51ms
[debug] [2023-07-18T16:14:59.636Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.637Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.637Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.637Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.638Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.638Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.638Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.639Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.639Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.639Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.640Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.640Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.641Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.641Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.641Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.642Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.644Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.644Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.645Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.645Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.645Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.646Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.646Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.646Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.647Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.647Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.647Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.648Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.648Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.648Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.649Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.649Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.650Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.650Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.650Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.653Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.656Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.657Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.657Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.658Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.658Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.660Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.660Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.660Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.661Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.661Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.662Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.662Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.662Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.662Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.663Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.663Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.663Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.665Z] <<< [apiv2][status] GET http://127.0.0.1:4400/ 200
[debug] [2023-07-18T16:14:59.666Z] <<< [apiv2][body] GET http://127.0.0.1:4400/ {"version":"12.4.0","origins":["http://127.0.0.1:4400","http://[::1]:4400"],"host":"127.0.0.1","port":4400}
[info] i  Found running emulator hub for project birch-collective-develop at http://127.0.0.1:4400 
[info] i  Exporting data to: /home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/db-local-data 
[debug] [2023-07-18T16:14:59.666Z] >>> [apiv2][query] GET http://127.0.0.1:4400/ [none]
[debug] [2023-07-18T16:14:59.670Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.671Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.671Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.672Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.672Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.673Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.673Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.674Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.674Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.674Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.675Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.675Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.675Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.676Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.676Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.676Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.676Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.679Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.680Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.680Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.680Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.681Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.681Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.681Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.682Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.682Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.682Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.683Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.683Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.683Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.683Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.684Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.684Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.684Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.685Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.685Z] <<< [apiv2][status] GET http://127.0.0.1:4400/ 200
[debug] [2023-07-18T16:14:59.685Z] <<< [apiv2][body] GET http://127.0.0.1:4400/ {"version":"12.4.0","origins":["http://127.0.0.1:4400","http://[::1]:4400"],"host":"127.0.0.1","port":4400}
[debug] [2023-07-18T16:14:59.685Z] >>> [apiv2][query] POST http://127.0.0.1:4400/_admin/export [none]
[debug] [2023-07-18T16:14:59.685Z] >>> [apiv2][body] POST http://127.0.0.1:4400/_admin/export {"path":"/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/db-local-data","initiatedBy":"exit"}
[debug] [2023-07-18T16:14:59.689Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.692Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.692Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.693Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.694Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.694Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.695Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.695Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.695Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.700Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.701Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.701Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.701Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.702Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.702Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.702Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.702Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.709Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.709Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.710Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.710Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.710Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.711Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.712Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.712Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.712Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.713Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.713Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.713Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.714Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.714Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.714Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.715Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.715Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.715Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.716Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.717Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.718Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.718Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.719Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.719Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.719Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.720Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.720Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.720Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.721Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.721Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.722Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.722Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.722Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.722Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.723Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.723Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.725Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.726Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.726Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.727Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.727Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.727Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.728Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.728Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.729Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.729Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.729Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.730Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.730Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.730Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.730Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.731Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.731Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.731Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.732Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.734Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.734Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.734Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.735Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.735Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.736Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.736Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.736Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.736Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.737Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.737Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.737Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.738Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.738Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.738Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.738Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.739Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.741Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.741Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.741Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.742Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.743Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.743Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.743Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.744Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.744Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.744Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.744Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.745Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.745Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.746Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.746Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.746Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.746Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.747Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.748Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.748Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.748Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.748Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.749Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.749Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.750Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.751Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.751Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.751Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.751Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.752Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.752Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.752Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.752Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.753Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.753Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.754Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.754Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.755Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.755Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.755Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.755Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.756Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.756Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.756Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.758Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.758Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.758Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.759Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.759Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.759Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.759Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.760Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.760Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.761Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.761Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.762Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.762Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.762Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.763Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.763Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.764Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.764Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.764Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.764Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.765Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.765Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.765Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.766Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.766Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.766Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.767Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.767Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.768Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.768Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.768Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.768Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.769Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.769Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.769Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.770Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.770Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.770Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.770Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.771Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.771Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.771Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.773Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.773Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.774Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.775Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.777Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.778Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.778Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.778Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.778Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.779Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.779Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.779Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.780Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.780Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.780Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.781Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.781Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.781Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.781Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.782Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.782Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.782Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.783Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.784Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.784Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.784Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.785Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.785Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.785Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.785Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.786Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.786Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.786Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.787Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.787Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.787Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.787Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.788Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.788Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.788Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.791Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.791Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.792Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.792Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.792Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.793Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.793Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.793Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.794Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.794Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.794Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.794Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.795Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.795Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.796Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.796Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.796Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.797Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.798Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.798Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.798Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.799Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.799Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.799Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.800Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.800Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.800Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.801Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.801Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.801Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.802Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.802Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.802Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.802Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.803Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.803Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.804Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.804Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.804Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.805Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.805Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.806Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.807Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.807Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.807Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.808Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.808Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.808Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.809Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.809Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.810Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.810Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.810Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.811Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.815Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.815Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.815Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.816Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.816Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.816Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.817Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.817Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.817Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.818Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.818Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.818Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.818Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.819Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.819Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.819Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.820Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.820Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.821Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.821Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.821Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.821Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.822Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.822Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.822Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.823Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.823Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.824Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.824Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.826Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.826Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.827Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.827Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.827Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.827Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.828Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.828Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.829Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.829Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.830Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.830Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.830Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.830Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.831Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.831Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.831Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.831Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.832Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.832Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.832Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.833Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.833Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.833Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.833Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.834Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.834Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.834Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.835Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.835Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.835Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.836Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.836Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.836Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.836Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.837Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.837Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.837Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.838Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.838Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.838Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.838Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.838Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.841Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.841Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.841Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.842Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.842Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.842Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.843Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.843Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.843Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.844Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.844Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.844Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.845Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.845Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.845Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.845Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.846Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.846Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.846Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.847Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.847Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.847Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.848Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.849Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.849Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.849Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.849Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.850Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.850Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.850Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[error] Error: An unexpected error has occurred.
[debug] [2023-07-18T16:14:59.850Z] Error: write EIO
    at afterWriteDispatched (node:internal/stream_base_commons:160:15)
    at writeGeneric (node:internal/stream_base_commons:151:3)
    at Socket._writeGeneric (node:net:930:11)
    at Socket._write (node:net:942:8)
    at writeOrBuffer (node:internal/streams/writable:392:12)
    at _write (node:internal/streams/writable:333:10)
    at Writable.write (node:internal/streams/writable:337:10)
    at Console.log (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston/lib/winston/transports/console.js:79:23)
    at Console._write (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/winston-transport/index.js:103:17)
    at doWrite (/home/ruben/.nvm/versions/node/v18.16.0/lib/node_modules/firebase-tools/node_modules/readable-stream/lib/_stream_writable.js:390:139)
[error] 
[debug] [2023-07-19T08:18:04.877Z] ----------------------------------------------------------------------
[debug] [2023-07-19T08:18:04.879Z] Command:       /home/ruben/.nvm/versions/node/v18.16.0/bin/node /home/ruben/.nvm/versions/node/v18.16.0/bin/firebase emulators:start --import=./db-local-data --export-on-exit=./db-local-data
[debug] [2023-07-19T08:18:04.879Z] CLI Version:   12.4.0
[debug] [2023-07-19T08:18:04.879Z] Platform:      linux
[debug] [2023-07-19T08:18:04.879Z] Node Version:  v18.16.0
[debug] [2023-07-19T08:18:04.881Z] Time:          Wed Jul 19 2023 09:18:04 GMT+0100 (British Summer Time)
[debug] [2023-07-19T08:18:04.881Z] ----------------------------------------------------------------------
[debug] 
[debug] [2023-07-19T08:18:04.884Z] >>> [apiv2][query] GET https://firebase-public.firebaseio.com/cli.json [none]
[debug] [2023-07-19T08:18:04.977Z] Object ".extensions" in "firebase.json" has unknown property: {"additionalProperty":"storage-resize-images"}
[debug] [2023-07-19T08:18:04.982Z] > command requires scopes: ["email","openid","https://www.googleapis.com/auth/cloudplatformprojects.readonly","https://www.googleapis.com/auth/firebase","https://www.googleapis.com/auth/cloud-platform"]
[debug] [2023-07-19T08:18:04.982Z] > authorizing via signed-in user (a.ruben00001@gmail.com)
[debug] [2023-07-19T08:18:05.121Z] java version "20.0.1" 2023-04-18

[debug] [2023-07-19T08:18:05.122Z] Java(TM) SE Runtime Environment (build 20.0.1+9-29)

[debug] [2023-07-19T08:18:05.122Z] Java HotSpot(TM) 64-Bit Server VM (build 20.0.1+9-29, mixed mode, sharing)

[debug] [2023-07-19T08:18:05.128Z] Parsed Java major version: 20
[info] i  emulators: Starting emulators: auth, functions, firestore, storage, extensions {"metadata":{"emulator":{"name":"hub"},"message":"Starting emulators: auth, functions, firestore, storage, extensions"}}
[debug] [2023-07-19T08:18:05.130Z] > refreshing access token with scopes: []
[debug] [2023-07-19T08:18:05.131Z] >>> [apiv2][query] POST https://www.googleapis.com/oauth2/v3/token [none]
[debug] [2023-07-19T08:18:05.131Z] >>> [apiv2][body] POST https://www.googleapis.com/oauth2/v3/token [omitted]
[debug] [2023-07-19T08:18:05.205Z] <<< [apiv2][status] POST https://www.googleapis.com/oauth2/v3/token 200
[debug] [2023-07-19T08:18:05.205Z] <<< [apiv2][body] POST https://www.googleapis.com/oauth2/v3/token [omitted]
[debug] [2023-07-19T08:18:05.211Z] >>> [apiv2][query] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop [none]
[debug] [2023-07-19T08:18:05.216Z] <<< [apiv2][status] GET https://firebase-public.firebaseio.com/cli.json 200
[debug] [2023-07-19T08:18:05.217Z] <<< [apiv2][body] GET https://firebase-public.firebaseio.com/cli.json {"cloudBuildErrorAfter":1594252800000,"cloudBuildWarnAfter":1590019200000,"defaultNode10After":1594252800000,"minVersion":"3.0.5","node8DeploysDisabledAfter":1613390400000,"node8RuntimeDisabledAfter":1615809600000,"node8WarnAfter":1600128000000}
[debug] [2023-07-19T08:18:05.453Z] <<< [apiv2][status] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop 200
[debug] [2023-07-19T08:18:05.453Z] <<< [apiv2][body] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop {"projectId":"birch-collective-develop","projectNumber":"796296843255","displayName":"birch-collective-develop","name":"projects/birch-collective-develop","resources":{"hostingSite":"birch-collective-develop","storageBucket":"birch-collective-develop.appspot.com","locationId":"europe-west2"},"state":"ACTIVE","etag":"1_83a82fa5-bad8-492e-952a-94b81202b519"}
[debug] [2023-07-19T08:18:05.454Z] Successfully read params from storage-resize-images.env
[debug] [2023-07-19T08:18:05.455Z] Error: ENOENT: no such file or directory, open '/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/extensions/storage-resize-images.env.default'
[debug] [2023-07-19T08:18:05.455Z] Error: ENOENT: no such file or directory, open '/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/extensions/storage-resize-images.env.796296843255'
[debug] [2023-07-19T08:18:05.455Z] Error: ENOENT: no such file or directory, open '/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/extensions/storage-resize-images.env.birch-collective-develop'
[debug] [2023-07-19T08:18:05.455Z] Error: ENOENT: no such file or directory, open '/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/extensions/storage-resize-images.env.local'
[debug] [2023-07-19T08:18:05.456Z] >>> [apiv2][query] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop/adminSdkConfig [none]
[debug] [2023-07-19T08:18:05.692Z] <<< [apiv2][status] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop/adminSdkConfig 200
[debug] [2023-07-19T08:18:05.692Z] <<< [apiv2][body] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop/adminSdkConfig {"projectId":"birch-collective-develop","storageBucket":"birch-collective-develop.appspot.com","locationId":"europe-west2"}
[debug] [2023-07-19T08:18:05.695Z] >>> [apiv2][query] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop [none]
[debug] [2023-07-19T08:18:05.918Z] <<< [apiv2][status] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop 200
[debug] [2023-07-19T08:18:05.918Z] <<< [apiv2][body] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop {"projectId":"birch-collective-develop","projectNumber":"796296843255","displayName":"birch-collective-develop","name":"projects/birch-collective-develop","resources":{"hostingSite":"birch-collective-develop","storageBucket":"birch-collective-develop.appspot.com","locationId":"europe-west2"},"state":"ACTIVE","etag":"1_83a82fa5-bad8-492e-952a-94b81202b519"}
[debug] [2023-07-19T08:18:05.920Z] >>> [apiv2][query] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images [none]
[debug] [2023-07-19T08:18:06.576Z] <<< [apiv2][status] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images 200
[debug] [2023-07-19T08:18:06.576Z] <<< [apiv2][body] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images {"name":"publishers/firebase/extensions/storage-resize-images","ref":"firebase/storage-resize-images","latestVersion":"0.1.38","latestVersionCreateTime":"2023-07-12T08:31:00.938559Z","state":"PUBLISHED","createTime":"2021-03-18T22:07:59.572345Z","iconUri":"https://storage.googleapis.com/firebase-extensions-icons/extension_icons/firebase/resize_images_120@2x.png","publisher":{"displayName":"Firebase","iconUri":"https://storage.googleapis.com/firebase-extensions-icons/publisher_icons/firebase/firebase_128dp.png"},"repoUri":"https://github.com/firebase/extensions","metrics":{"activeInstallCount":"18600"},"latestApprovedVersion":"0.1.38"}
[debug] [2023-07-19T08:18:06.577Z] >>> [apiv2][query] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images/versions filter=&showPrereleases=true&pageSize=100&pageToken=
[debug] [2023-07-19T08:18:07.760Z] <<< [apiv2][status] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images/versions 200
[debug] [2023-07-19T08:18:07.767Z] <<< [apiv2][body] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images/versions {"extensionVersions":[{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.0","ref":"firebase/storage-resize-images@0.1.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores both images in the same Cloud Storage bucket.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/commits/master","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Deployment location","type":"SELECT","description":"Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1"},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"(.)+\\.(.)+\\.(.)+","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-image).\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n\n- Creates resized image(s) with your specfied dimensions.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# storage-resize-images\n\n**VERSION**: 0.1.0\n\n**DESCRIPTION**: Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.\n\n\n\n**CONFIGURATION PARAMETERS:**\n\n* Deployment location: Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-image).\n\n\n* Cache-Control header for resized images: Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n\n\n\n\n**CLOUD FUNCTIONS CREATED:**\n\n* generateResizedImage (google.storage.object.finalize)\n\n\n\n**DETAILS**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n**APIS USED**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**ACCESS REQUIRED**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"ae8734a79a3808c0e5baadb2129a07db978b017bcfa6aa3dd974a3b87cdccc7d","createTime":"2019-09-18T20:52:33.938873796Z","id":"0.1.0","releaseNotes":"Initial release of the _Resize Images_ extension.\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"500"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.1","ref":"firebase/storage-resize-images@0.1.1","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.1","description":"Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores both images in the same Cloud Storage bucket.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/releases","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Deployment location","type":"SELECT","description":"Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1"},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"(.)+\\.(.)+\\.(.)+","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n\n- Creates resized image(s) with your specfied dimensions.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# storage-resize-images\n\n**VERSION**: 0.1.0\n\n**DESCRIPTION**: Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.\n\n\n\n**CONFIGURATION PARAMETERS:**\n\n* Deployment location: Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Cache-Control header for resized images: Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n\n\n\n\n**CLOUD FUNCTIONS CREATED:**\n\n* generateResizedImage (google.storage.object.finalize)\n\n\n\n**DETAILS**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n**APIS USED**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**ACCESS REQUIRED**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"0e640d83d7a7df47082e1ecb8ee586aaf547cf7f22ff1b37f86f04ed10284a55","createTime":"2019-10-17T17:19:34.531333517Z","id":"0.1.1","releaseNotes":"fixed - Fixed bug where certain edge cases led to already resized image being resized again. (issue #7)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"700"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.10","ref":"firebase/storage-resize-images@0.1.10","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.10","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"5b6aaad19e4055fd5a4d43a3310e0b2d1fad45d097b924d15cffb92419949f4a","createTime":"2020-06-25T17:23:56.517417Z","id":"0.1.10","releaseNotes":"fixed - A fresh token is now generated for each resized image. (Issue #323, PR #351)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"1500"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.11","ref":"firebase/storage-resize-images@0.1.11","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.11","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nruntime: nodejs10\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"a6334c9b51015839f41340e8d8edcf420d0028fea6ca6dcf3c9fbc3269b975c1","createTime":"2020-09-01T17:11:44.235295Z","id":"0.1.11","releaseNotes":"feature - Update Cloud Functions runtime to Node.js 10.\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"100"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.12","ref":"firebase/storage-resize-images@0.1.12","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.12","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nruntime: nodejs10\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"137bb35c38deb264c2ab107b4565ddea56dcef315b6f682317599b74105f59d0","createTime":"2020-09-10T17:15:34.956867Z","id":"0.1.12","releaseNotes":"fixed - ignore gzipped images (PR #417)\n\nfeature - Add new Cloud Functions locations. For more information about locations and their pricing tiers, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"600"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.13","ref":"firebase/storage-resize-images@0.1.13","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.13","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs10\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred type","type":"SELECT","description":"The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","options":[{"value":"jpg","label":"jpg"},{"value":"png","label":"png"},{"value":"webp","label":"webp"},{"value":"tiff","label":"tiff"},{"value":"false","label":"Do not convert"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"707fa9ef9d2b8131dc232f5e096a8cecdbcff237137d04e8c65333c32089f646","createTime":"2020-11-05T17:03:34.934877Z","id":"0.1.13","releaseNotes":"feature - Add new parameter to optionally convert each uploaded image to a different image content-type (PR #483)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"100"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.14","ref":"firebase/storage-resize-images@0.1.14","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.14","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs10\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred type","type":"SELECT","description":"The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","options":[{"value":"jpg","label":"jpg"},{"value":"png","label":"png"},{"value":"webp","label":"webp"},{"value":"tiff","label":"tiff"},{"value":"false","label":"Do not convert"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred type: The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"bd8a63899ae4900c93c1f7f937c6ce1980572cb1fab47e6b2fe2ebb9766d4806","createTime":"2020-11-19T19:40:37.624195Z","id":"0.1.14","releaseNotes":"feature - Added a \"delete only on success\" option to the `DELETE_ORIGINAL_FILE` param (#479)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"100"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.16","ref":"firebase/storage-resize-images@0.1.16","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.16","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs10\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred type","type":"SELECT","description":"The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","options":[{"value":"jpg","label":"jpg"},{"value":"png","label":"png"},{"value":"webp","label":"webp"},{"value":"tiff","label":"tiff"},{"value":"false","label":"Do not convert"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred type: The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"39a474a801a2ec9906dd0489f50ea3caf18866d8260b2e201a519c02ab4bc4af","createTime":"2020-12-10T18:42:54.259365Z","id":"0.1.16","releaseNotes":"feature - Adds support for absolute paths restrictions for Storage Resize Image (#427)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"300"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.17","ref":"firebase/storage-resize-images@0.1.17","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.17","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs10\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred type","type":"SELECT","description":"The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","options":[{"value":"jpg","label":"jpg"},{"value":"png","label":"png"},{"value":"webp","label":"webp"},{"value":"tiff","label":"tiff"},{"value":"false","label":"Do not convert"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred type: The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"b90cae92b70e9bf6e4eab4ee92d8ae1fadfd5466f1442abec2973ccff0e475ee","createTime":"2021-01-14T17:46:16.836237Z","id":"0.1.17","releaseNotes":"docs - Adds documentation that explains which content types are supported, and shows how to set content type explicitly (#534)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"200"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.18","ref":"firebase/storage-resize-images@0.1.18","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.18","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs10\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred type","type":"SELECT","description":"The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","options":[{"value":"jpg","label":"jpg"},{"value":"png","label":"png"},{"value":"webp","label":"webp"},{"value":"tiff","label":"tiff"},{"value":"false","label":"Do not convert"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n\n#### Configuration Parameters\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred type: The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"4b3d920bb9c035e1b94bd6ccb5901af956d8c2ec63b38d369f53d3941cbf9a90","createTime":"2021-02-11T23:35:52.318567Z","id":"0.1.18","releaseNotes":"fixed - fixed a bug that caused resized images to be named incorrectly if their file extension was capitalized (#549)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"200"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.19","ref":"firebase/storage-resize-images@0.1.19","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.19","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs10\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"false","label":"original"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n\n#### Configuration Parameters\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"85653802698bb12bd4d4090b8de56f5f807c15d000756870395ecfd4815ece66","createTime":"2021-03-04T17:50:05.876197Z","id":"0.1.19","releaseNotes":"feature - Adds support for converting to more than one image format (#579)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"500"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.21","ref":"firebase/storage-resize-images@0.1.21","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.21","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs10\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"false","label":"original"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"a7252a179c6a38ac80d10fbb932eabb7e922b627090a07b91babb9b0c9a57c0e","createTime":"2021-04-15T21:30:45.121285Z","id":"0.1.21","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"600"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.22","ref":"firebase/storage-resize-images@0.1.22","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.22","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"false","label":"original"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n\n#### Configuration Parameters\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"d19f44e0cd23c5ea45a2bba07e7390cfe27b967826a8d601b89412e1362a1ecb","createTime":"2021-06-17T18:04:05.400316Z","id":"0.1.22","releaseNotes":"feature - added Warsaw (europe-central2) location (#677)\n\nfeature - updated Cloud Functions runtime to Node.js 14 (#660)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"1300"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.23","ref":"firebase/storage-resize-images@0.1.23","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.23","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"false","label":"original"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"4bd7c2a4ea1dff1c17f73cb988158a53c4a30cce318ce2ec73fabbead5d30693","createTime":"2021-10-20T18:21:31.562784Z","id":"0.1.23","releaseNotes":"feature - add Taiwan and Singapore Cloud Function locations (#729)\n","listing":{"state":"APPROVED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.24","ref":"firebase/storage-resize-images@0.1.24","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.24","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"false","label":"original"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"d0d2709ca16a418e9750ab2fa924fcdc2de5d45dc91d281b3479995dbf1036bf","createTime":"2021-10-21T13:47:27.093269Z","id":"0.1.24","releaseNotes":"fixed - update package lock file to fix installation errors (#782)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"400"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.25","ref":"firebase/storage-resize-images@0.1.25","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.25","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"false","label":"original"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"d4eaafe5234bfc6dbb096a8ea35bb0d32ee8861cb95532d8dd3fa9d0a7239211","createTime":"2021-12-13T21:57:29.342985Z","id":"0.1.25","releaseNotes":"fixed - fix errors when resizing Samsung-encoded JPEGs\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"700"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.26","ref":"firebase/storage-resize-images@0.1.26","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.26","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"false","label":"original"}],"default":"false"},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- \n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"cc530d81657d24f53ae4da1415642169fa2f8f321cd6f8d540e2dffdf1b698dc","createTime":"2022-03-07T16:50:58.893124Z","id":"0.1.26","releaseNotes":"fixed - generate correct `package-lock.json` files after `lerna bootstrap` (#779)\n\nfixed - update resized metadata content disposition (#839)\n\nfeature - add WEBP and GIF animation (#875)\n\nfixed - update validate workflow to use node14\n\nfixed - fix samsung encoded jpg resizing\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"200"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.26-rc.1","ref":"firebase/storage-resize-images@0.1.26-rc.1","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.26-rc.1","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"false","label":"original"}],"default":"false"},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- \n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"a822632bbe7b33034ebab0c053b8735839c925f3d90db4cd0757d1b33de7aac0","createTime":"2022-03-02T21:28:30.026260Z","id":"0.1.26-rc.1","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.27","ref":"firebase/storage-resize-images@0.1.27","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.27","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"f35b38ba04316e2c1740d926d5e0600ab27162a3e72b39c30c7188015c523cda","createTime":"2022-04-07T18:48:34.715302Z","id":"0.1.27","releaseNotes":"fixed - update to firebase-admin v10 (#935)\n\nfeature - add output options param, to support [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg) (#878)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"200"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.28","ref":"firebase/storage-resize-images@0.1.28","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.28","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for all changes made to your specified Cloud Storage bucket, finds any images, and resizes them. Resized images are stored in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"181466310919029d32f2df067e30058ad456e9eac0bb145e5481b1359a5758fc","createTime":"2022-05-10T16:07:21.268515Z","id":"0.1.28","releaseNotes":"feature - added extension event for image resize completion (#967)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"800"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.29","ref":"firebase/storage-resize-images@0.1.29","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.29","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"53c3ef614c8aa474091fcd18c8d688a841d5f28433599a50036e0cfa1e47536b","createTime":"2022-08-09T22:14:28.416069Z","id":"0.1.29","releaseNotes":"fixed - add size to metadata\n\nfeature - add an option to make the resized images public\n\nfixed - updated sharp lib dependency for improved compression algorithm\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"400"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.3","ref":"firebase/storage-resize-images@0.1.3","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.3","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/releases","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Deployment location","type":"SELECT","description":"Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"(.)+\\.(.)+\\.(.)+","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following metadata, if present, from the original image to the resized image(s):\n\n- [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control)\n- [`Content-Disposition`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Disposition)\n- [`Content-Encoding`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Encoding)\n- [`Content-Language`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Language)\n- [`Content-Type`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type)\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nNote that if you configured the `Cache-Control header for resized images` param, the specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Deployment location: Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"7a1283da29e4e66e45b79a6bef975480a388100b15aeaabba13db31b6f71a8ea","createTime":"2019-11-21T19:21:08.486676552Z","id":"0.1.3","releaseNotes":"feature - Automatically copy the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can configure your extension to overwrite the Cache-Control value for the resized image(s).\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"800"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.30","ref":"firebase/storage-resize-images@0.1.30","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.30","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"64d49102709cb18e65b6d6896091f72cbbf7306a87f4077631b93126539b09ce","createTime":"2022-09-29T18:22:00.156454Z","id":"0.1.30","releaseNotes":"feature - include original image data in events\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"600"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.30-rc.0","ref":"firebase/storage-resize-images@0.1.30-rc.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.30-rc.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"3df443606881f0415ca85f956345a78b616295c7f82133b88f90795c8883dff3","createTime":"2022-09-28T15:32:54.115340Z","id":"0.1.30-rc.0","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.31","ref":"firebase/storage-resize-images@0.1.31","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.31","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"85bb47ae9d602a01516a67499aee1a078fc4af804468a76f0a69e682c3a5385f","createTime":"2022-11-21T18:51:58.619150Z","id":"0.1.31","releaseNotes":"feature - add AVIF codec support\n\nfeature - update IMG_BUCKET param type to selectResource\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"100"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.31-rc.0","ref":"firebase/storage-resize-images@0.1.31-rc.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.31-rc.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"595d4422e5660a03be6ffc1bc08f638aba4b4fe8c0e4b3fbedeeb3e19ea17fc4","createTime":"2022-11-16T09:50:49.612394Z","id":"0.1.31-rc.0","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.31-rc.1","ref":"firebase/storage-resize-images@0.1.31-rc.1","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.31-rc.1","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"a1b095524da27dea748bbc9922d935a9b85dcd27f53d2ab0a255faa8c405a5e1","createTime":"2022-11-16T13:55:57.517370Z","id":"0.1.31-rc.1","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.32","ref":"firebase/storage-resize-images@0.1.32","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.32","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"946f89a07cfc8d420128a0f6ed21f488ceff0bef00ddef013f3bd4d638402fa8","createTime":"2022-12-05T17:05:39.269479Z","id":"0.1.32","releaseNotes":"feature - added lifecycle event to resize existing images\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"200"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.32-rc.0","ref":"firebase/storage-resize-images@0.1.32-rc.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.32-rc.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"a733e12e0104994f88a8fa892a7f05b6adf8f1e72b1107e8c02d441760daa346","createTime":"2022-12-01T22:24:07.954720Z","id":"0.1.32-rc.0","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.33","ref":"firebase/storage-resize-images@0.1.33","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.33","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"2c70a453af018330671a8ca63af31676f8ef7ee9c58a9d452d7f3c0255ebaa13","createTime":"2023-01-06T09:15:59.836425Z","id":"0.1.33","releaseNotes":"fixed - re-add input object data to the complete event\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"300"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.33-rc.0","ref":"firebase/storage-resize-images@0.1.33-rc.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.33-rc.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would match `/users/profile/pictures/image.png` as well as  `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/users/pictures` and `/restaurants/menuItems` directories, specify the paths `/users/pictures,/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures`  would exclude `/users/profile/pictures/image.png` as well as `/users/profile/pictures/any/sub/directory/image.png`. \nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"c00310215a913e01b8086863c8fcf7c54534a3a653b7a8c7da7472a955f828b2","createTime":"2023-01-05T17:17:39.571251Z","id":"0.1.33-rc.0","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.34","ref":"firebase/storage-resize-images@0.1.34","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.34","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"e4bebdc6c35b8b3920bed5fe5e9ced34d2b8709c16d9b658f9f7f8fa8bb0423d","createTime":"2023-02-08T12:01:49.735289Z","id":"0.1.34","releaseNotes":"feature - upgrade extensions to the latest firebase-admin sdk\n\nfixed - support backfill task in custom region\n\nfeature - add description to the failedImagesPath param\n\nfeature - put failed resizes in separate directory #563\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"400"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.34-rc.0","ref":"firebase/storage-resize-images@0.1.34-rc.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.34-rc.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"54cf6b24023875e0a0d064e948f01281daf8c7c7b6680fabb8c9c362f5fb2dd2","createTime":"2023-02-08T10:18:43.398137Z","id":"0.1.34-rc.0","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.35","ref":"firebase/storage-resize-images@0.1.35","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.35","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"7f12461bf80bc00b378332cd51d5375913e204ea006f5a04a435eacdfe0dfb54","createTime":"2023-03-17T16:20:20.728921Z","id":"0.1.35","releaseNotes":"feature - handle jfif extensions correctly\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"200"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.35-rc.0","ref":"firebase/storage-resize-images@0.1.35-rc.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.35-rc.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"84854e3f2b380279aae462fe08b6a0ee740ddcb45607109049e58bf31c8a7554","createTime":"2023-03-17T11:08:18.520029Z","id":"0.1.35-rc.0","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.35-rc.1","ref":"firebase/storage-resize-images@0.1.35-rc.1","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.35-rc.1","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"f6c273d14364e202c727054e3c53dbba4cc55c917ceabda58dd394a2036cb52c","createTime":"2023-03-17T15:51:54.538429Z","id":"0.1.35-rc.1","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.36","ref":"firebase/storage-resize-images@0.1.36","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.36","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"53459008c80d2746fca36a5c25ca94e3fb03a7b565f5299905a76c1ad0d3f823","createTime":"2023-04-05T14:33:20.703655Z","id":"0.1.36","releaseNotes":"fixed - added fixes for gcs vulnerabilities\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"700"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.36-rc.0","ref":"firebase/storage-resize-images@0.1.36-rc.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.36-rc.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs14\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs14\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly exclude any directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"a299e65b763903d86e6480bc4cc2cef3ce470e8b69181d3d0a928458e51f3a3a","createTime":"2023-04-05T14:04:27.144128Z","id":"0.1.36-rc.0","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.37","ref":"firebase/storage-resize-images@0.1.37","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.37","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs16\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs16\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"008e9b78f75cc2082febea52eb76a3c2e17f90f23f90e7b0f5bdfe9a43aa6c81","createTime":"2023-06-07T17:38:42.485685Z","id":"0.1.37","releaseNotes":"feature - bump to nodejs16\n\nfixed - correct include path list description\n","buildSourceUri":"https://github.com/firebase/extensions/tree/25537363d0d4416fd5d9326a0d5f452fd6e342f3","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"600"},"extensionRoot":"storage-resize-images"},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.37-rc.0","ref":"firebase/storage-resize-images@0.1.37-rc.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.37-rc.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs16\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs16\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"2c7381c0a52c465ebfe5cf84ffe8c54a69e124fa4fd1f26f7df25c86bc4bc672","createTime":"2023-06-06T16:26:29.964259Z","id":"0.1.37-rc.0","buildSourceUri":"https://github.com/firebase/extensions/tree/56b4e9aa09971c65eca8e3e14065ca567e7b2e55","listing":{"state":"UNLISTED"},"extensionRoot":"storage-resize-images"},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.38","ref":"firebase/storage-resize-images@0.1.38","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.38","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nruntime: nodejs18\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nruntime: nodejs18\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true},{"param":"firebaseextensions.v1beta.function/location","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your database. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true}]},"state":"PUBLISHED","hash":"0192f0f7a558e821739b6ad0452247eabc19a9bef8091f04bcd2afe15b5b1294","createTime":"2023-07-12T08:31:00.938559Z","id":"0.1.38","releaseNotes":"feature - bump to node 18\n","buildSourceUri":"https://github.com/firebase/extensions/tree/8705822e3a07191d38fcfff9f5ab6878ce227823","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"100"},"extensionRoot":"storage-resize-images"},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.38-rc.0","ref":"firebase/storage-resize-images@0.1.38-rc.0","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.38-rc.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nruntime: nodejs18\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nruntime: nodejs18\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true},{"param":"firebaseextensions.v1beta.function/location","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your database. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true}]},"state":"PUBLISHED","hash":"f78fa62e5e4f6bb33e54e2bb8be8ae58811a6c20d69df7be9d9746d76c1fd1b8","createTime":"2023-07-11T15:44:50.964991Z","id":"0.1.38-rc.0","buildSourceUri":"https://github.com/firebase/extensions/tree/fb7db1eb9b83dd533711a491764732a57da7643e","listing":{"state":"UNLISTED"},"extensionRoot":"storage-resize-images"},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.4","ref":"firebase/storage-resize-images@0.1.4","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.4","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following metadata, if present, from the original image to the resized image(s):\n\n- [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control)\n- [`Content-Disposition`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Disposition)\n- [`Content-Encoding`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Encoding)\n- [`Content-Language`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Language)\n- [`Content-Type`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type)\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nNote that if you configured the `Cache-Control header for resized images` param, the specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"c86d57ccd6d5a684a218a3d8c3fd7ee981f8b6c265598a549a061efa2101077e","createTime":"2020-01-16T18:19:34.532055498Z","id":"0.1.4","releaseNotes":"fixed - Fixed bug where name of resized file was missing original name if there was no file extension. (issue #20)\n\nfixed - Fixed \"TypeError: Cannot set property 'resizedImage' of undefined\". (issue #130)\n\nfixed - Fixed bug where some valid bucket names were rejected during configuration. (issue #27)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"900"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.5","ref":"firebase/storage-resize-images@0.1.5","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.5","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"9596eaf7533fe73df3b7e449a862466048e25c8d83b1edcddc3db1947cd873ef","createTime":"2020-04-09T17:19:22.670451672Z","id":"0.1.5","releaseNotes":"fixed - The original, uploaded image's MIME type must now always be specified in the `Content-Type` header. (Issue #175)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"300"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.0-rc.1","ref":"firebase/storage-resize-images@0.1.0-rc.1","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores both images in the same Cloud Storage bucket.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://dev-partners.googlesource.com/samples/firebase/mods/+log","sourceUrl":"https://accounts.google.com/AccountChooser/signinchooser?service=gerritcodereview&continue=https%3A%2F%2Fdev-partners.googlesource.com%2Flogin%2Fsamples%2Ffirebase%2Fmods%2F%2B%2Fmaster%2Fstorage-resize-images","params":[{"param":"LOCATION","label":"Deployment location","type":"SELECT","description":"Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1"},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"(.)+\\.(.)+\\.(.)+","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-image).\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension creates a resized image with your specified dimensions. It stores both the resized image and the original image in the same Storage bucket. The extension names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height. For example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket. Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension creates resized image(s) with your specfied dimensions. It stores both the resized image(s) and the original image in the same bucket, `${param:IMG_BUCKET}`. The extension names a resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# storage-resize-images\n\n**VERSION**: 0.1.0\n\n**DESCRIPTION**: Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.\n\n\n\n**CONFIGURATION PARAMETERS:**\n\n* Deployment location: *Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).*\n\n* Cloud Storage bucket for images: *To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n*\n\n* Sizes of resized images: *What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n*\n\n* Cloud Storage path for resized images: *A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-image).\n*\n\n* Cache-Control header for resized images: *Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n*\n\n\n\n**NON-CLOUD FUNCTION RESOURCES CREATED**:\n\n* generateResizedImage (firebaseextensions.v1beta.function)\n\n\n\n**DETAILS**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension creates a resized image with your specified dimensions. It stores both the resized image and the original image in the same Storage bucket. The extension names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height. For example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n**APIS USED**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**ACCESS REQUIRED**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","createTime":"2019-09-12T20:31:32.735300678Z","id":"0.1.0-rc.1","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.0-rc.2","ref":"firebase/storage-resize-images@0.1.0-rc.2","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.0","description":"Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores both images in the same Cloud Storage bucket.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/commits/master","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Deployment location","type":"SELECT","description":"Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1"},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"(.)+\\.(.)+\\.(.)+","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-image).\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n- Creates resized image(s) with your specfied dimensions.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# storage-resize-images\n\n**VERSION**: 0.1.0\n\n**DESCRIPTION**: Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.\n\n\n\n**CONFIGURATION PARAMETERS:**\n\n* Deployment location: Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-image).\n\n\n* Cache-Control header for resized images: Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n\n\n\n\n**CLOUD FUNCTIONS CREATED:**\n\n* generateResizedImage (google.storage.object.finalize)\n\n\n\n**DETAILS**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n**APIS USED**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**ACCESS REQUIRED**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","createTime":"2019-09-18T16:45:41.559534413Z","id":"0.1.0-rc.2","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.1-rc.1","ref":"firebase/storage-resize-images@0.1.1-rc.1","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.1","description":"Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores both images in the same Cloud Storage bucket.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/commits/master","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Deployment location","type":"SELECT","description":"Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1"},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"(.)+\\.(.)+\\.(.)+","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-image).\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n\n- Creates resized image(s) with your specfied dimensions.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# storage-resize-images\n\n**VERSION**: 0.1.0\n\n**DESCRIPTION**: Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.\n\n\n\n**CONFIGURATION PARAMETERS:**\n\n* Deployment location: Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-image).\n\n\n* Cache-Control header for resized images: Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n\n\n\n\n**CLOUD FUNCTIONS CREATED:**\n\n* generateResizedImage (google.storage.object.finalize)\n\n\n\n**DETAILS**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n**APIS USED**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**ACCESS REQUIRED**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","createTime":"2019-10-14T19:00:02.187428910Z","id":"0.1.1-rc.1","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.1-rc.2","ref":"firebase/storage-resize-images@0.1.1-rc.2","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.1","description":"Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores both images in the same Cloud Storage bucket.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/releases","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Deployment location","type":"SELECT","description":"Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1"},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"(.)+\\.(.)+\\.(.)+","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n\n- Creates resized image(s) with your specfied dimensions.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# storage-resize-images\n\n**VERSION**: 0.1.0\n\n**DESCRIPTION**: Resizes images uploaded to Cloud Storage to a specified size, and stores both the original and resized images.\n\n\n\n**CONFIGURATION PARAMETERS:**\n\n* Deployment location: Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? This bucket will store both the original and resized images.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values.\n\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-image).\n\n\n* Cache-Control header for resized images: Do you want to specify a `Cache-Control` header for the resized image files? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to use a `Cache-Control` header, leave this field empty.\n\n\n\n\n**CLOUD FUNCTIONS CREATED:**\n\n* generateResizedImage (google.storage.object.finalize)\n\n\n\n**DETAILS**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nAnother optional feature of this extension is to specify a [`Cache-Control` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) for your resized image files.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n**APIS USED**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**ACCESS REQUIRED**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","createTime":"2019-10-15T22:49:45.589434762Z","id":"0.1.1-rc.2","listing":{"state":"UNLISTED"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.16-rc.1","ref":"firebase/storage-resize-images@0.1.16-rc.1","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.16","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs10\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"},{"value":"on_success","label":"Delete on successful resize"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred type","type":"SELECT","description":"The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n","options":[{"value":"jpg","label":"jpg"},{"value":"png","label":"png"},{"value":"webp","label":"webp"},{"value":"tiff","label":"tiff"},{"value":"false","label":"Do not convert"}],"default":"false"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n \nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n \n- You will be charged a small amount (typically around $0.01/month) for the Firebase resources required by this extension (even if it is not used).\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s free tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#expandable-24))\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to only resize the images  stored in `/users/pictures` directory, specify the path `/users/pictures`.  If you prefer to resize every image uploaded to the storage bucket,  leave this field empty.\n\n\n* List of absolute paths not included for resized images: A comma-separated list of absolute paths to not take into account for  images to be resized. For example, to not resize the images  stored in `/users/pictures/avatars` directory, specify the path  `/users/pictures/avatars`. If you prefer to resize every image uploaded  to the storage bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred type: The image type you'd like your source image to convert to. The default for this option will  be to keep the original file type.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","createTime":"2020-12-03T20:37:21.202540Z","id":"0.1.16-rc.1","listing":{"state":"UNLISTED"},"metrics":{"activeInstallCount":"80"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.4-rc.1","ref":"firebase/storage-resize-images@0.1.4-rc.1","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.4","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Deployment location","type":"SELECT","description":"Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following metadata, if present, from the original image to the resized image(s):\n\n- [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control)\n- [`Content-Disposition`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Disposition)\n- [`Content-Encoding`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Encoding)\n- [`Content-Language`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Language)\n- [`Content-Type`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type)\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nNote that if you configured the `Cache-Control header for resized images` param, the specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Deployment location: Where should the extension be deployed? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","createTime":"2020-01-09T18:10:50.007899289Z","id":"0.1.4-rc.1","listing":{"state":"UNLISTED"},"metrics":{"activeInstallCount":"100"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.5-rc.1","ref":"firebase/storage-resize-images@0.1.5-rc.1","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.5","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following metadata, if present, from the original image to the resized image(s):\n\n- [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control)\n- [`Content-Disposition`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Disposition)\n- [`Content-Encoding`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Encoding)\n- [`Content-Language`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Language)\n- [`Content-Type`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type)\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","createTime":"2020-03-05T18:15:20.965699655Z","id":"0.1.5-rc.1","listing":{"state":"UNLISTED"},"metrics":{"activeInstallCount":"200"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.6","ref":"firebase/storage-resize-images@0.1.6","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.6","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"fc1ff54f6d77722ecd86cbe9fcfc69be618a23bee4e58dee48bba844d839df84","createTime":"2020-04-23T17:17:59.966539870Z","id":"0.1.6","releaseNotes":"fixed - Switched ImageMagick for Sharp library to support webp format. (Issue #199)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"300"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.7","ref":"firebase/storage-resize-images@0.1.7","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.7","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"eb333fcdfff9795fb1cd02ae737493270721fc44068b8a1983a0aa20479f132b","createTime":"2020-05-07T17:13:51.872987459Z","id":"0.1.7","releaseNotes":"fixed - Resized images now render in the Firebase console. (Issue #140)\n\nfixed - The Sharp cache is now cleared so that the latest image with a given\nfile name is retrieved from the Storage bucket. (Issue #286)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"300"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.8","ref":"firebase/storage-resize-images@0.1.8","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.8","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"b02ebe65202c3535bad8e69daf46767be76102858277af1bc33654e588acc5e7","createTime":"2020-05-20T17:55:21.556770994Z","id":"0.1.8","releaseNotes":"fixed - Resized images now maintain the same orientation as the original image. (Issue #290)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"500"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.9","ref":"firebase/storage-resize-images@0.1.9","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.9","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"DEPRECATED","hash":"a139bcfefbf19e901b67789105a3841ed208c6e449a896bafcc4a01e43c07844","createTime":"2020-06-11T18:12:20.333403Z","id":"0.1.9","releaseNotes":"changed - If the original image is a vector image, the extension does not resize it. (Issue #326, PR #329)\n\nfixed - Replaced `mkdirp-promise` with `mkdirp` because `mkdirp-promise` is deprecated. (PR #266)\n\nfixed - If the original image is smaller than the specified max width and height, the extension does not enlarge it or resize it. (Issue #337, PR #338)\n","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"300"}},{"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.5-rc.2","ref":"firebase/storage-resize-images@0.1.5-rc.2","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.5","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: 1024\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${IMG_BUCKET}\nlocation: ${LOCATION}\nsourceDirectory: .\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"}],"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Mike Diarmid","email":"mike@invertase.io","url":"https://github.com/salakar"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"STRING","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket"},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n","postinstallContent":"### See it in action\n\nYou can test out this extension right away:\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage).\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhen you upload an image file to `${param:IMG_BUCKET}`, this extension:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following metadata, if present, from the original image to the resized image(s):\n\n- [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control)\n- [`Content-Disposition`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Disposition)\n- [`Content-Encoding`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Encoding)\n- [`Content-Language`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Language)\n- [`Content-Type`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type)\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata) (except Firebase storage download tokens)\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`).\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n","readmeContent":"# Resize Images\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload an image file to your specified Cloud Storage bucket, this extension:\n\n- Creates a resized image with your specified dimensions.\n- Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n- Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (except Firebase storage download tokens). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n#### Billing\n\nThis extension uses other Firebase or Google Cloud Platform services which may have associated charges:\n\n- Cloud Storage\n- Cloud Functions\n\nWhen you use Firebase Extensions, you're only charged for the underlying resources that you use. A paid-tier billing plan is only required if the extension uses a service that requires a paid-tier plan, for example calling to a Google Cloud Platform API or making outbound network requests to non-Google services. All Firebase services offer a free tier of usage. [Learn more about Firebase billing.](https://firebase.google.com/pricing)\n\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension?  You usually want a location close to your Storage bucket. For help selecting a  location, refer to the [location selection  guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted.\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Note that these deletions cannot be undone.\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","displayName":"Resize Images","systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","createTime":"2020-03-19T18:14:15.960944126Z","id":"0.1.5-rc.2","listing":{"state":"UNLISTED"},"metrics":{"activeInstallCount":"500"}}]}
[debug] [2023-07-19T08:18:07.787Z] >>> [apiv2][query] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images/versions/0.1.37 [none]
[debug] [2023-07-19T08:18:08.475Z] <<< [apiv2][status] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images/versions/0.1.37 200
[debug] [2023-07-19T08:18:08.476Z] <<< [apiv2][body] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images/versions/0.1.37 {"name":"publishers/firebase/extensions/storage-resize-images/versions/0.1.37","ref":"firebase/storage-resize-images@0.1.37","spec":{"specVersion":"v1beta","name":"storage-resize-images","version":"0.1.37","description":"Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.","apis":[{"apiName":"storage-component.googleapis.com","reason":"Needed to use Cloud Storage"}],"roles":[{"role":"storage.admin","reason":"Allows the extension to store resized images in Cloud Storage"}],"resources":[{"name":"generateResizedImage","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\neventTrigger:\n  eventType: google.storage.object.finalize\n  resource: projects/_/buckets/${param:IMG_BUCKET}\nlocation: ${param:LOCATION}\nruntime: nodejs16\n","description":"Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.","deletionPolicy":"DELETE"},{"name":"backfillResizedImages","type":"firebaseextensions.v1beta.function","propertiesYaml":"availableMemoryMb: ${param:FUNCTION_MEMORY}\nlocation: ${LOCATION}\nruntime: nodejs16\ntaskQueueTrigger: {}\n","description":"Handles tasks from startBackfill to resize existing images.","deletionPolicy":"DELETE"}],"billingRequired":true,"author":{"authorName":"Firebase","url":"https://firebase.google.com"},"contributors":[{"authorName":"Tina Liang","url":"https://github.com/tinaliang"},{"authorName":"Chris Bianca","email":"chris@csfrequency.com","url":"https://github.com/chrisbianca"},{"authorName":"Invertase","email":"oss@invertase.io","url":"https://github.com/invertase"}],"license":"Apache-2.0","releaseNotesUrl":"https://github.com/firebase/extensions/blob/master/storage-resize-images/CHANGELOG.md","sourceUrl":"https://github.com/firebase/extensions/tree/master/storage-resize-images","params":[{"param":"LOCATION","label":"Cloud Functions location","type":"SELECT","description":"Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).","required":true,"options":[{"value":"us-central1","label":"Iowa (us-central1)"},{"value":"us-east1","label":"South Carolina (us-east1)"},{"value":"us-east4","label":"Northern Virginia (us-east4)"},{"value":"us-west2","label":"Los Angeles (us-west2)"},{"value":"us-west3","label":"Salt Lake City (us-west3)"},{"value":"us-west4","label":"Las Vegas (us-west4)"},{"value":"europe-central2","label":"Warsaw (europe-central2)"},{"value":"europe-west1","label":"Belgium (europe-west1)"},{"value":"europe-west2","label":"London (europe-west2)"},{"value":"europe-west3","label":"Frankfurt (europe-west3)"},{"value":"europe-west6","label":"Zurich (europe-west6)"},{"value":"asia-east1","label":"Taiwan (asia-east1)"},{"value":"asia-east2","label":"Hong Kong (asia-east2)"},{"value":"asia-northeast1","label":"Tokyo (asia-northeast1)"},{"value":"asia-northeast2","label":"Osaka (asia-northeast2)"},{"value":"asia-northeast3","label":"Seoul (asia-northeast3)"},{"value":"asia-south1","label":"Mumbai (asia-south1)"},{"value":"asia-southeast1","label":"Singapore (asia-southeast1)"},{"value":"asia-southeast2","label":"Jakarta (asia-southeast2)"},{"value":"northamerica-northeast1","label":"Montreal (northamerica-northeast1)"},{"value":"southamerica-east1","label":"Sao Paulo (southamerica-east1)"},{"value":"australia-southeast1","label":"Sydney (australia-southeast1)"}],"default":"us-central1","immutable":true},{"param":"IMG_BUCKET","label":"Cloud Storage bucket for images","type":"SELECT_RESOURCE","description":"To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"${STORAGE_BUCKET}","example":"my-project-12345.appspot.com","validationRegex":"^([0-9a-z_.-]*)$","validationErrorMessage":"Invalid storage bucket","resourceInfo":{"resourceType":"storage.googleapis.com/Bucket"}},{"param":"IMG_SIZES","label":"Sizes of resized images","type":"STRING","description":"What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n","required":true,"default":"200x200","example":"200x200","validationRegex":"^\\d+x(\\d+,\\d+x)*\\d+$","validationErrorMessage":"Invalid sizes, must be a comma-separated list of WIDTHxHEIGHT values."},{"param":"DELETE_ORIGINAL_FILE","label":"Deletion of original file","type":"SELECT","description":"Do you want to automatically delete the original file from the Cloud Storage bucket? warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.","required":true,"options":[{"value":"false","label":"Don't delete"},{"value":"true","label":"Delete on any resize attempt"},{"value":"on_success","label":"Delete only on successful resize attempts"}],"default":"false"},{"param":"MAKE_PUBLIC","label":"Make resized images public","type":"SELECT","description":"Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}],"default":"false"},{"param":"RESIZED_IMAGES_PATH","label":"Cloud Storage path for resized images","type":"STRING","description":"A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n","example":"thumbnails"},{"param":"INCLUDE_PATH_LIST","label":"Paths that contain images you want to resize","type":"STRING","description":"Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n","example":"/users/avatars,/design/pictures","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"EXCLUDE_PATH_LIST","label":"List of absolute paths not included for resized images","type":"STRING","description":"Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n","example":"/users/avatars/thumbs,/design/pictures/thumbs","validationRegex":"^(\\/[^\\s\\/\\,]+)+(\\,(\\/[^\\s\\/\\,]+)+)*$","validationErrorMessage":"Invalid paths, must be a comma-separated list of absolute path values."},{"param":"FAILED_IMAGES_PATH","label":"Cloud Storage path for failed images","type":"STRING","description":"A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n","example":"failed"},{"param":"CACHE_CONTROL_HEADER","label":"Cache-Control header for resized images","type":"STRING","description":"This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n","example":"max-age=86400"},{"param":"IMAGE_TYPE","label":"Convert image to preferred types","type":"MULTISELECT","description":"The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n","required":true,"options":[{"value":"jpeg","label":"jpeg"},{"value":"webp","label":"webp"},{"value":"png","label":"png"},{"value":"tiff","label":"tiff"},{"value":"gif","label":"gif"},{"value":"avif","label":"avif"},{"value":"false","label":"original"}],"default":"false"},{"param":"OUTPUT_OPTIONS","label":"Output options for selected formats","type":"STRING","description":"Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n","validationRegex":"^({(.*?)})$","validationErrorMessage":"Please provide a valid json object."},{"param":"IS_ANIMATED","label":"GIF and WEBP animated option","type":"SELECT","description":"Keep animation of GIF and WEBP formats.\n","options":[{"value":"true","label":"Yes"},{"value":"false","label":"No (1st frame only)"}],"default":"true"},{"param":"FUNCTION_MEMORY","label":"Cloud Function memory","type":"SELECT","description":"Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).","required":true,"options":[{"value":"512","label":"512 MB"},{"value":"1024","label":"1 GB"},{"value":"2048","label":"2 GB"}],"default":"1024"},{"param":"DO_BACKFILL","label":"Backfill existing images","type":"SELECT","description":"Should existing, unresized images in the Storage bucket be resized as well?\n","required":true,"options":[{"value":"true","label":"Yes"},{"value":"false","label":"No"}]}],"preinstallContent":"Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","postinstallContent":"### See it in action\n\nYou can test out this extension right away!\n\n1.  Go to your [Storage dashboard](https://console.firebase.google.com/project/${param:PROJECT_ID}/storage) in the Firebase console.\n\n1.  Upload an image file to the bucket: `${param:IMG_BUCKET}`\n\n1.  In a few seconds, the resized image(s) appear in the same bucket.\n\n    Note that you might need to refresh the page to see changes.\n\n### Using the extension\n\nYou can upload images using the [Cloud Storage for Firebase SDK](https://firebase.google.com/docs/storage/) for your platform (iOS, Android, or Web). Alternatively, you can upload images directly in the Firebase console's Storage dashboard.\n\nWhenever you upload an image file to `${param:IMG_BUCKET}`, this extension does the following:\n\n- Creates resized image(s) with your specfied dimensions.\n- Names resized image(s) using the same name as the original uploaded image, but suffixed with the specified width and height.\n- Stores the resized image(s) in the bucket `${param:IMG_BUCKET}` (and, if configured, under the path `${param:RESIZED_IMAGES_PATH}`).\n\nThe extension also copies the following [metadata](https://cloud.google.com/storage/docs/metadata#mutable), if present, from the original image to the resized image(s):\n\n- `Cache-Control`\n- `Content-Disposition`\n- `Content-Encoding`\n- `Content-Language`\n- `Content-Type`\n- [user-provided metadata](https://cloud.google.com/storage/docs/metadata#custom-metadata)\n - If the original image contains a download token (publically accessible via a unique download URL), a new download token is generated for the resized image(s). \n - If the orginal image does not contain a download token, resized image(s) will not be created with unique tokens. To make a resized image publically accessible, call the [`getDownloadURL`](https://firebase.google.com/docs/reference/js/firebase.storage.Reference#getdownloadurl) method.\n\nBe aware of the following when using this extension:\n\n- Each original image must have a valid [image MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Image_types) specified in its [`Content-Type` metadata](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type) (for example, `image/png`). Below is a list of the content types supported by this extension:\n  * image/jpeg\n  * image/png\n  * image/tiff\n  * image/webp\n  * image/gif\n\nIf you are using raw image data in your application, you need to ensure you set the correct content type when uploading to the Firebase Storage bucket to trigger the extension image resize. Below is an example of how to set the content type:\n\n```js\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Sucessfully uploaded image\");\n    }\n  );\n}\n```\n\n- If you configured the `Cache-Control header for resized images` parameter, your specified value will overwrite the value copied from the original image. Learn more about image metadata in the [Cloud Storage documentation](https://firebase.google.com/docs/storage/).\n\n- If you would like to optionally configure `Output options for selected formats` you can create an JSON stringfied object where you can provide file [Sharp Output Options](https://sharp.pixelplumbing.com/api-output#jpeg). Please use file formats as object keys and pass correct options. Incorrect options parameters or not selected formats will be ignored. Provide it as stringfied JSON object without outer quote signs and indentation:\n\n```js\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n### Monitoring\n\nAs a best practice, you can [monitor the activity](https://firebase.google.com/docs/extensions/manage-installed-extensions#monitor) of your installed extension, including checks on its health, usage, and logs.\n\n### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)","readmeContent":"# Resize Images\n\n**Author**: Firebase (**[https://firebase.google.com](https://firebase.google.com)**)\n\n**Description**: Resizes images uploaded to Cloud Storage to a specified size, and optionally keeps or deletes the original image.\n\n\n\n**Details**: Use this extension to create resized versions of an image uploaded to a Cloud Storage bucket.\n\nWhen you upload a file to your specified Cloud Storage bucket, this extension:\n\n- Detects if the file is an image. If it is, then:\n  - Creates a resized image with your specified dimensions.\n  - Names the resized image using the same name as the original uploaded image, but suffixed with your specified width and height.\n  - Stores the resized image in the same Storage bucket as the original uploaded image.\n\nYou can even configure the extension to create resized images of different dimensions for each original image upload. For example, you might want images that are 200x200, 400x400, and 680x680 - this extension can create these three resized images then store them in your bucket.\n\nThe extension automatically copies the following metadata, if present, from the original image to the resized image(s): `Cache-Control`, `Content-Disposition`, `Content-Encoding`, `Content-Language`, `Content-Type`, and user-provided metadata (a new Firebase storage download token will be generated on the resized image(s) if the original metadata contains a token). Note that you can optionally configure the extension to overwrite the [`Cache-Control`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control) value for the resized image(s).\n\nThe extension supports resizing images in `JPEG`, `PNG`, `WebP`, `GIF`, `AVIF` and `TIFF` formats, and the output can be in one or more of these formats.\n\nThe extension can publish a resize completion event which you can optionally enable when you install the extension. If you enable events, you can [write custom event handlers](https://firebase.google.com/docs/extensions/install-extensions#eventarc) that respond to these events. You can always enable or disable events later. Events will be emitted via Eventarc.\n\n#### Detailed configuration information\n\nTo configure this extension, you specify a maximum width and a maximum height (in pixels, px). This extension keeps the aspect ratio of uploaded images constant and shrinks the image until the resized image's dimensions are at or under your specified max width and height.\n\nFor example, say that you specify a max width of 200px and a max height of 100px. You upload an image that is 480px wide by 640px high, which means a 0.75 aspect ratio. The final resized image will be 75px wide by 100px high to maintain the aspect ratio while also being at or under both of your maximum specified dimensions.\n\n#### Additional setup\n\nBefore installing this extension, make sure that you've [set up a Cloud Storage bucket](https://firebase.google.com/docs/storage) in your Firebase project.\n\n> **NOTE**: As mentioned above, this extension listens for all changes made to the specified Cloud Storage bucket. This may cause unnecessary function calls. It is recommended to create a separate Cloud Storage bucket, especially for images you want to resize, and set up this extension to listen to that bucket.\n\n#### Multiple instances of this extension\n\nYou can install multiple instances of this extension for the same project to configure different resizing options for different paths. However, as mentioned before this extension listens for all changes made to the specified Cloud Storage bucket. That means all instances will be triggered every time a file is uploaded to the bucket. Therefore, it is recommended to use different buckets instead of different paths to prevent unnecessary function calls.\n\n#### Troubleshooting\n\nIf events are enabled, and you want to create custom event handlers to respond to the events published by the extension, you must ensure that you have the appropriate [role/permissions](https://cloud.google.com/pubsub/docs/access-control#permissions_and_roles) to subscribe to Pub/Sub events.\n\n#### Billing\nTo install an extension, your project must be on the [Blaze (pay as you go) plan](https://firebase.google.com/pricing)\n\n- This extension uses other Firebase and Google Cloud Platform services, which have associated charges if you exceed the service’s no-cost tier:\n - Cloud Storage\n - Cloud Functions (Node.js 10+ runtime. [See FAQs](https://firebase.google.com/support/faq#extensions-pricing))\n- If you enable events [Eventarc fees apply](https://cloud.google.com/eventarc/pricing).\n\n#### Further reading & resources\n\nYou can find more information about this extension in the following articles:\n\n- [Image Optimization With Firebase Extensions](https://invertase.link/ext-resize-images-tutorial)\n\n\n\n**Configuration Parameters:**\n\n* Cloud Functions location: Where do you want to deploy the functions created for this extension? You usually want a location close to your Storage bucket. For help selecting a location, refer to the [location selection guide](https://firebase.google.com/docs/functions/locations).\n\n* Cloud Storage bucket for images: To which Cloud Storage bucket will you upload images that you want to resize? Resized images will be stored in this bucket. Depending on your extension configuration, original images are either kept or deleted. It is recommended to create a separate bucket for this extension. For more information, refer to the [pre-installation guide](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Sizes of resized images: What sizes of images would you like (in pixels)? Enter the sizes as a comma-separated list of WIDTHxHEIGHT values. Learn more about [how this parameter works](https://firebase.google.com/products/extensions/storage-resize-images).\n\n\n* Deletion of original file: Do you want to automatically delete the original file from the Cloud Storage bucket? Warning: these deletions cannot be undone, and if you reconfigure this instance to use different image dimensions, you won't be able to backfill deleted images.\n\n* Make resized images public: Do you want to make the resized images public automatically? So you can access them by URL. For example: https://storage.googleapis.com/{bucket}/{path}\n\n* Cloud Storage path for resized images: A relative path in which to store resized images. For example, if you specify a path here of `thumbs` and you upload an image to `/images/original.jpg`, then the resized image is stored at `/images/thumbs/original_200x200.jpg`. If you prefer to store resized images at the root of your bucket, leave this field empty.\n\n\n* Paths that contain images you want to resize: Restrict storage-resize-images to only resize images in specific locations in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, specifying the paths `/users/pictures,/restaurants/menuItems` will resize any images found in any subdirectories of `/users/pictures` and `/restaurants/menuItems`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would include any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`. \nIf you prefer not to explicitly restrict to certain directories of your Storage bucket, leave this field empty.\n\n\n* List of absolute paths not included for resized images: Ensure storage-resize-images does *not* resize images in _specific locations_ in your Storage bucket by  supplying a comma-separated list of absolute paths. For example, to *exclude* the images  stored in the `/foo/alpha` and its subdirectories and `/bar/beta` and its subdirectories, specify the paths `/foo/alpha,/bar/beta`.\nYou may also use wildcard notation for directories in the path. For example, `/users/*/pictures` would exclude any images in any subdirectories of `/users/foo/pictures` as well as any images in subdirectories of `/users/bar/pictures`, but also any images in subdirectories of `/users/any/level/of/subdirectories/pictures`.\nIf you prefer to resize every image uploaded to your Storage bucket,  leave this field empty.\n\n\n* Cloud Storage path for failed images: A relative path in which to store failed images. For example, if you specify a path here of `failed` and you upload an image to `/images/original.jpg`, then resizing failed, the image will be stored at `/images/failed/original.jpg`.\nLeave this field empty if you do not want to store failed images in a separate directory.\n\n\n* Cache-Control header for resized images: This extension automatically copies any `Cache-Control` metadata from the original image to the resized images. For the resized images, do you want to overwrite this copied `Cache-Control` metadata or add `Cache-Control` metadata? Learn more about [`Cache-Control` headers](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control). If you prefer not to overwrite or add `Cache-Control` metadata, leave this field empty.\n\n\n* Convert image to preferred types: The image types you'd like your source image to convert to.  The default for this option will be to keep the original file type as the destination file type.\n\n\n* Output options for selected formats: Provide a optional output option stringified object containing Sharp Output Options for selected image types conversion. eg. `{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"pallete\": true }}`\n\n\n* GIF and WEBP animated option: Keep animation of GIF and WEBP formats.\n\n\n* Cloud Function memory: Memory of the function responsible of resizing images.  Choose how much memory to give to the function that resize images. (For animated GIF => GIF we recommend using a minimum of 2GB).\n\n* Backfill existing images: Should existing, unresized images in the Storage bucket be resized as well?\n\n\n\n\n**Cloud Functions:**\n\n* **generateResizedImage:** Listens for new images uploaded to your specified Cloud Storage bucket, resizes the images, then stores the resized images in the same bucket. Optionally keeps or deletes the original images.\n\n* **backfillResizedImages:** Handles tasks from startBackfill to resize existing images.\n\n\n\n**APIs Used**:\n\n* storage-component.googleapis.com (Reason: Needed to use Cloud Storage)\n\n\n\n**Access Required**:\n\n\n\nThis extension will operate with the following project IAM roles:\n\n* storage.admin (Reason: Allows the extension to store resized images in Cloud Storage)\n","lifecycleEvents":[{"stage":"ON_INSTALL","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_UPDATE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"},{"stage":"ON_CONFIGURE","processingMessage":"Resizing existing images in ${param:IMG_BUCKET}","taskQueueTriggerFunction":"backfillResizedImages"}],"displayName":"Resize Images","events":[{"type":"firebase.extensions.storage-resize-images.v1.complete","description":"Occurs when image resizing completes. The event will contain further details about specific formats and sizes."}],"systemParams":[{"param":"firebaseextensions.v1beta.function/memory","label":"Function memory","type":"SELECT","description":"How much memory should be allocated to each function?","options":[{"value":"128","label":"128MB"},{"value":"256","label":"256MB"},{"value":"512","label":"512MB"},{"value":"1024","label":"1GB"},{"value":"2048","label":"2GB"},{"value":"4096","label":"4GB"},{"value":"8192","label":"8GB"}],"default":"256","advanced":true},{"param":"firebaseextensions.v1beta.function/timeoutSeconds","label":"Function timeout seconds","type":"STRING","description":"How long should functions run before timing out, in seconds (0-540)?","validationRegex":"^[1-9][0-9]{0,2}$","validationErrorMessage":"Function timeout should be an integer number of seconds, between 0 and 540","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnector","label":"VPC Connector","type":"STRING","description":"The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is projects/*/locations/*/connectors/*.","validationRegex":"^projects/([^/]+)/locations/([^/]+)/connectors/([^/]+)$","advanced":true},{"param":"firebaseextensions.v1beta.function/vpcConnectorEgressSettings","label":"VPC Connector Egress settings","type":"SELECT","description":"Controls outgoing traffic when a VPC connector is configured","options":[{"value":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","label":"Unspecified"},{"value":"PRIVATE_RANGES_ONLY","label":"Private ranges only"},{"value":"ALL_TRAFFIC","label":"All traffic"}],"default":"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED","advanced":true},{"param":"firebaseextensions.v1beta.function/minInstances","label":"Minimum function instances","type":"STRING","description":"The minimum number of instances of each function to run at once (0-1000)","default":"0","validationRegex":"^[0-9]*$","validationErrorMessage":"Min instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/maxInstances","label":"Maximum function instances","type":"STRING","description":"The maximum number of instances of each function to run at once","default":"3000","validationRegex":"^[0-9]*$","validationErrorMessage":"Max instances must be a non-negative integer.","advanced":true},{"param":"firebaseextensions.v1beta.function/ingressSettings","label":"Function ingress settings","type":"SELECT","description":"Where should functions allow incoming traffic from?","options":[{"value":"ALLOW_ALL","label":"Allow all"},{"value":"ALLOW_INTERNAL_ONLY","label":"Allow internal only"},{"value":"ALLOW_INTERNAL_AND_GCLB","label":"Allow internal and GCLB"}],"advanced":true},{"param":"firebaseextensions.v1beta.function/labels","label":"Function labels","type":"STRING","description":"Do you wish to set any labels on this instance's Cloud Functions? If so, provide up to 55 labels in the format 'key1:value, key2:value'","validationRegex":"^([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63},\\s*)*([a-zžà-ÿ][A-Za-zŽžÀ-ÿ0-9_-]{0,62}:[A-Za-zŽžÀ-ÿ0-9_-]{0,63})$","advanced":true}]},"state":"PUBLISHED","hash":"008e9b78f75cc2082febea52eb76a3c2e17f90f23f90e7b0f5bdfe9a43aa6c81","createTime":"2023-06-07T17:38:42.485685Z","sourceDownloadUri":"https://storage.googleapis.com/firebase-mod-sources-prod/008e9b78f75cc2082febea52eb76a3c2e17f90f23f90e7b0f5bdfe9a43aa6c81","id":"0.1.37","releaseNotes":"feature - bump to nodejs16\n\nfixed - correct include path list description\n","buildSourceUri":"https://github.com/firebase/extensions/tree/25537363d0d4416fd5d9326a0d5f452fd6e342f3","listing":{"state":"APPROVED"},"metrics":{"activeInstallCount":"600"},"extensionRoot":"storage-resize-images"}
[debug] [2023-07-19T08:18:08.503Z] [extensions] Source code valid for firebase/storage-resize-images@0.1.37
[warn] ⚠  Function 'backfillResizedImages is missing a trigger in extension.yaml. Please add one, as triggers defined in code are ignored. {"metadata":{"emulator":{"name":"functions"},"message":"Function 'backfillResizedImages is missing a trigger in extension.yaml. Please add one, as triggers defined in code are ignored."}}
[debug] [2023-07-19T08:18:08.505Z] >>> [apiv2][query] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images [none]
[debug] [2023-07-19T08:18:09.155Z] <<< [apiv2][status] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images 200
[debug] [2023-07-19T08:18:09.155Z] <<< [apiv2][body] GET https://firebaseextensions.googleapis.com/v1beta/publishers/firebase/extensions/storage-resize-images {"name":"publishers/firebase/extensions/storage-resize-images","ref":"firebase/storage-resize-images","latestVersion":"0.1.38","latestVersionCreateTime":"2023-07-12T08:31:00.938559Z","state":"PUBLISHED","createTime":"2021-03-18T22:07:59.572345Z","iconUri":"https://storage.googleapis.com/firebase-extensions-icons/extension_icons/firebase/resize_images_120@2x.png","publisher":{"displayName":"Firebase","iconUri":"https://storage.googleapis.com/firebase-extensions-icons/publisher_icons/firebase/firebase_128dp.png"},"repoUri":"https://github.com/firebase/extensions","metrics":{"activeInstallCount":"18600"},"latestApprovedVersion":"0.1.38"}
[debug] [2023-07-19T08:18:09.164Z] [functions] Functions Emulator only supports listening on one address (127.0.0.1). Not listening on ::1
[debug] [2023-07-19T08:18:09.164Z] [eventarc] Eventarc Emulator only supports listening on one address (127.0.0.1). Not listening on ::1
[debug] [2023-07-19T08:18:09.164Z] [logging] Logging Emulator only supports listening on one address (127.0.0.1). Not listening on ::1
[debug] [2023-07-19T08:18:09.165Z] assigned listening specs for emulators {"user":{"ui":[{"address":"127.0.0.1","family":"IPv4","port":4000}],"auth":[{"address":"127.0.0.1","family":"IPv4","port":9099}],"firestore":[{"address":"127.0.0.1","family":"IPv4","port":8080}],"firestore.websocket":[{"address":"127.0.0.1","family":"IPv4","port":9150}],"storage":[{"address":"127.0.0.1","family":"IPv4","port":9199}],"functions":[{"address":"127.0.0.1","family":"IPv4","port":5001}],"eventarc":[{"address":"127.0.0.1","family":"IPv4","port":9299}],"hub":[{"address":"127.0.0.1","family":"IPv4","port":4400},{"address":"::1","family":"IPv6","port":4400}],"logging":[{"address":"127.0.0.1","family":"IPv4","port":4500}]},"metadata":{"message":"assigned listening specs for emulators"}}
[debug] [2023-07-19T08:18:09.236Z] [hub] writing locator at /tmp/hub-birch-collective-develop.json
[debug] [2023-07-19T08:18:09.257Z] [Extensions] Started Extensions emulator, this is a noop.
[warn] ⚠  functions: The following emulators are not running, calls to these services from the Functions emulator will affect production: database, hosting, pubsub {"metadata":{"emulator":{"name":"functions"},"message":"The following emulators are not running, calls to these services from the Functions emulator will affect production: \u001b[1mdatabase, hosting, pubsub\u001b[22m"}}
[debug] [2023-07-19T08:18:09.273Z] defaultcredentials: writing to file /home/ruben/.config/firebase/a_ruben00001_gmail.com_application_default_credentials.json
[debug] [2023-07-19T08:18:09.296Z] Setting GAC to /home/ruben/.config/firebase/a_ruben00001_gmail.com_application_default_credentials.json {"metadata":{"emulator":{"name":"functions"},"message":"Setting GAC to /home/ruben/.config/firebase/a_ruben00001_gmail.com_application_default_credentials.json"}}
[debug] [2023-07-19T08:18:09.297Z] >>> [apiv2][query] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop/adminSdkConfig [none]
[debug] [2023-07-19T08:18:09.535Z] <<< [apiv2][status] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop/adminSdkConfig 200
[debug] [2023-07-19T08:18:09.535Z] <<< [apiv2][body] GET https://firebase.googleapis.com/v1beta1/projects/birch-collective-develop/adminSdkConfig {"projectId":"birch-collective-develop","storageBucket":"birch-collective-develop.appspot.com","locationId":"europe-west2"}
[info] i  firestore: Importing data from /home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/db-local-data/firestore_export/firestore_export.overall_export_metadata {"metadata":{"emulator":{"name":"firestore"},"message":"Importing data from /home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/db-local-data/firestore_export/firestore_export.overall_export_metadata"}}
[debug] [2023-07-19T08:18:09.555Z] Ignoring unsupported arg: auto_download {"metadata":{"emulator":{"name":"firestore"},"message":"Ignoring unsupported arg: auto_download"}}
[debug] [2023-07-19T08:18:09.555Z] Ignoring unsupported arg: single_project_mode_error {"metadata":{"emulator":{"name":"firestore"},"message":"Ignoring unsupported arg: single_project_mode_error"}}
[debug] [2023-07-19T08:18:09.555Z] Starting Firestore Emulator with command {"binary":"java","args":["-Dgoogle.cloud_firestore.debug_log_level=FINE","-Duser.language=en","-jar","/home/ruben/.cache/firebase/emulators/cloud-firestore-emulator-v1.17.4.jar","--host","127.0.0.1","--port",8080,"--websocket_port",9150,"--project_id","birch-collective-develop","--seed_from_export","/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/db-local-data/firestore_export/firestore_export.overall_export_metadata","--rules","/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/firestore.rules","--single_project_mode",true,"--functions_emulator","127.0.0.1:5001"],"optionalArgs":["port","webchannel_port","host","rules","websocket_port","functions_emulator","seed_from_export","project_id","single_project_mode"],"joinArgs":false} {"metadata":{"emulator":{"name":"firestore"},"message":"Starting Firestore Emulator with command {\"binary\":\"java\",\"args\":[\"-Dgoogle.cloud_firestore.debug_log_level=FINE\",\"-Duser.language=en\",\"-jar\",\"/home/ruben/.cache/firebase/emulators/cloud-firestore-emulator-v1.17.4.jar\",\"--host\",\"127.0.0.1\",\"--port\",8080,\"--websocket_port\",9150,\"--project_id\",\"birch-collective-develop\",\"--seed_from_export\",\"/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/db-local-data/firestore_export/firestore_export.overall_export_metadata\",\"--rules\",\"/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/firestore.rules\",\"--single_project_mode\",true,\"--functions_emulator\",\"127.0.0.1:5001\"],\"optionalArgs\":[\"port\",\"webchannel_port\",\"host\",\"rules\",\"websocket_port\",\"functions_emulator\",\"seed_from_export\",\"project_id\",\"single_project_mode\"],\"joinArgs\":false}"}}
[info] i  firestore: Firestore Emulator logging to firestore-debug.log {"metadata":{"emulator":{"name":"firestore"},"message":"Firestore Emulator logging to \u001b[1mfirestore-debug.log\u001b[22m"}}
[debug] [2023-07-19T08:18:13.005Z] Jul 19, 2023 9:18:12 AM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketServer start
INFO: Started WebSocket server on ws://127.0.0.1:9150
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:18:12 AM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketServer start\nINFO: Started WebSocket server on ws://127.0.0.1:9150\n"}}
[debug] [2023-07-19T08:18:13.046Z] API endpoint: http:// {"metadata":{"emulator":{"name":"firestore"},"message":"API endpoint: http://"}}
[debug] [2023-07-19T08:18:13.047Z] 127.0.0.1:8080
If you are using a library that supports the FIRESTORE_EMULATOR_HOST environment variable, run:

   export FIRESTORE_EMULATOR_HOST=127.0.0.1:8080

Dev App Server is now running.

 {"metadata":{"emulator":{"name":"firestore"},"message":"127.0.0.1:8080\nIf you are using a library that supports the FIRESTORE_EMULATOR_HOST environment variable, run:\n\n   export FIRESTORE_EMULATOR_HOST=127.0.0.1:8080\n\nDev App Server is now running.\n\n"}}
[info] ✔  firestore: Firestore Emulator UI websocket is running on 9150. {"metadata":{"emulator":{"name":"firestore"},"message":"Firestore Emulator UI websocket is running on 9150."}}
[info] i  auth: Importing config from /home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/db-local-data/auth_export/config.json {"metadata":{"emulator":{"name":"auth"},"message":"Importing config from /home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/db-local-data/auth_export/config.json"}}
[info] i  auth: Importing accounts from /home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/db-local-data/auth_export/accounts.json {"metadata":{"emulator":{"name":"auth"},"message":"Importing accounts from /home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/db-local-data/auth_export/accounts.json"}}
[debug] [2023-07-19T08:18:22.670Z] Ignoring unsupported arg: port {"metadata":{"emulator":{"name":"storage"},"message":"Ignoring unsupported arg: port"}}
[debug] [2023-07-19T08:18:22.935Z] Jul 19, 2023 9:18:22 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:18:22 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:18:22.936Z] Jul 19, 2023 9:18:22 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:18:22 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:18:23.150Z] Jul 19, 2023 9:18:23 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:18:23 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:18:24.028Z] Temp file directory for storage emulator: /tmp/firebase/storage/blobs {"metadata":{"emulator":{"name":"storage"},"message":"Temp file directory for storage emulator: /tmp/firebase/storage/blobs"}}
[debug] [2023-07-19T08:18:24.072Z] Ignoring unsupported arg: auto_download {"metadata":{"emulator":{"name":"ui"},"message":"Ignoring unsupported arg: auto_download"}}
[debug] [2023-07-19T08:18:24.073Z] Ignoring unsupported arg: port {"metadata":{"emulator":{"name":"ui"},"message":"Ignoring unsupported arg: port"}}
[debug] [2023-07-19T08:18:24.073Z] Starting Emulator UI with command {"binary":"node","args":["/home/ruben/.cache/firebase/emulators/ui-v1.11.6/server/server.js"],"optionalArgs":[],"joinArgs":false} {"metadata":{"emulator":{"name":"ui"},"message":"Starting Emulator UI with command {\"binary\":\"node\",\"args\":[\"/home/ruben/.cache/firebase/emulators/ui-v1.11.6/server/server.js\"],\"optionalArgs\":[],\"joinArgs\":false}"}}
[info] i  ui: Emulator UI logging to ui-debug.log {"metadata":{"emulator":{"name":"ui"},"message":"Emulator UI logging to \u001b[1mui-debug.log\u001b[22m"}}
[debug] [2023-07-19T08:18:24.186Z] Web / API server started at 127.0.0.1:4000
 {"metadata":{"emulator":{"name":"ui"},"message":"Web / API server started at 127.0.0.1:4000\n"}}
[debug] [2023-07-19T08:18:24.338Z] [Extensions] Connecting Extensions emulator, this is a noop.
[info] i  functions: Watching "/home/ruben/.cache/firebase/extensions/firebase/storage-resize-images@0.1.37/functions" for Cloud Functions... {"metadata":{"emulator":{"name":"functions"},"message":"Watching \"/home/ruben/.cache/firebase/extensions/firebase/storage-resize-images@0.1.37/functions\" for Cloud Functions..."}}
[info] ✔  functions: Loaded functions definitions from source: generateResizedImage, backfillResizedImages. {"metadata":{"emulator":{"name":"functions"},"message":"Loaded functions definitions from source: generateResizedImage, backfillResizedImages."}}
[debug] [2023-07-19T08:18:24.340Z] addStorageTrigger {"eventTrigger":{"eventType":"google.storage.object.finalize","resource":"projects/_/buckets/birch-collective-develop.appspot.com","service":"storage.googleapis.com"}}
[info] ✔  functions[europe-west2-ext-storage-resize-images-generateResizedImage]: storage function initialized. {"metadata":{"emulator":{"name":"functions"},"message":"\u001b[1mstorage\u001b[22m function initialized."}}
[warn] ⚠  Unsupported function type on ext-storage-resize-images-backfillResizedImages. Expected either an httpsTrigger, eventTrigger, or blockingTrigger. {"metadata":{"emulator":{"name":"functions"},"message":"Unsupported function type on ext-storage-resize-images-backfillResizedImages. Expected either an httpsTrigger, eventTrigger, or blockingTrigger."}}
[info] i  functions[europe-west2-ext-storage-resize-images-backfillResizedImages]: function ignored because the unknown emulator does not exist or is not running. {"metadata":{"emulator":{"name":"functions"},"message":"function ignored because the unknown emulator does not exist or is not running."}}
[info] i  functions: Watching "/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/functions" for Cloud Functions... {"metadata":{"emulator":{"name":"functions"},"message":"Watching \"/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/functions\" for Cloud Functions..."}}
[debug] [2023-07-19T08:18:24.345Z] Validating nodejs source
[debug] [2023-07-19T08:18:25.253Z] > [functions] package.json contents: {
  "name": "functions",
  "description": "Cloud Functions for Firebase",
  "scripts": {
    "serve": "firebase emulators:start --only functions",
    "shell": "firebase functions:shell",
    "start": "npm run shell",
    "deploy": "firebase deploy --only functions",
    "logs": "firebase functions:log"
  },
  "engines": {
    "node": "18"
  },
  "main": "index.js",
  "dependencies": {
    "firebase-admin": "^11.8.0",
    "firebase-functions": "^4.3.1"
  },
  "devDependencies": {
    "firebase-functions-test": "^3.1.0"
  },
  "private": true
}
[debug] [2023-07-19T08:18:25.253Z] Building nodejs source
[debug] [2023-07-19T08:18:25.253Z] Failed to find version of module node: reached end of search path /home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/functions/node_modules
[info] ✔  functions: Using node@18 from host. 
[debug] [2023-07-19T08:18:25.256Z] Could not find functions.yaml. Must use http discovery
[debug] [2023-07-19T08:18:25.259Z] Found firebase-functions binary at '/home/ruben/Coding/website-builds/birch-collective/version-june_2023/cms/functions/node_modules/.bin/firebase-functions'
[debug] [2023-07-19T08:18:25.427Z] Serving at port 8483

[debug] [2023-07-19T08:18:25.580Z] Got response from /__/functions.yaml {"endpoints":{},"specVersion":"v1alpha1","requiredAPIs":[]}
[debug] [2023-07-19T08:18:25.586Z] shutdown requested via /__/quitquitquit

[info] ✔  functions: Loaded functions definitions from source: . {"metadata":{"emulator":{"name":"functions"},"message":"Loaded functions definitions from source: ."}}
[info] 
┌─────────────────────────────────────────────────────────────┐
│ ✔  All emulators ready! It is now safe to connect your app. │
│ i  View Emulator UI at http://127.0.0.1:4000/               │
└─────────────────────────────────────────────────────────────┘

┌────────────────┬────────────────┬──────────────────────────────────┐
│ Emulator       │ Host:Port      │ View in Emulator UI              │
├────────────────┼────────────────┼──────────────────────────────────┤
│ Authentication │ 127.0.0.1:9099 │ http://127.0.0.1:4000/auth       │
├────────────────┼────────────────┼──────────────────────────────────┤
│ Functions      │ 127.0.0.1:5001 │ http://127.0.0.1:4000/functions  │
├────────────────┼────────────────┼──────────────────────────────────┤
│ Firestore      │ 127.0.0.1:8080 │ http://127.0.0.1:4000/firestore  │
├────────────────┼────────────────┼──────────────────────────────────┤
│ Storage        │ 127.0.0.1:9199 │ http://127.0.0.1:4000/storage    │
├────────────────┼────────────────┼──────────────────────────────────┤
│ Extensions     │ 127.0.0.1:5001 │ http://127.0.0.1:4000/extensions │
└────────────────┴────────────────┴──────────────────────────────────┘
  Emulator Hub running at 127.0.0.1:4400
  Other reserved ports: 4500, 9150
┌─────────────────────────┬───────────────────────────────────────┬────────────────────────────────────────────────────────┐
│ Extension Instance Name │ Extension Ref                         │ View in Emulator UI                                    │
├─────────────────────────┼───────────────────────────────────────┼────────────────────────────────────────────────────────┤
│ storage-resize-images   │ firebase/storage-resize-images@0.1.37 │ http://127.0.0.1:4000/extensions/storage-resize-images │
└─────────────────────────┴───────────────────────────────────────┴────────────────────────────────────────────────────────┘
Issues? Report them at https://github.com/firebase/firebase-tools/issues and attach the *-debug.log files.
 
[debug] [2023-07-19T08:18:28.754Z] Jul 19, 2023 9:18:28 AM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketChannelHandler initChannel
INFO: Connected to new websocket client
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:18:28 AM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketChannelHandler initChannel\nINFO: Connected to new websocket client\n"}}
[debug] [2023-07-19T08:18:28.778Z] Jul 19, 2023 9:18:28 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:18:28 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:18:28.913Z] Jul 19, 2023 9:18:28 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:18:28 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:18:29.063Z] Jul 19, 2023 9:18:29 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:18:29 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:18:29.223Z] Jul 19, 2023 9:18:29 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:18:29 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:18:31.171Z] Jul 19, 2023 9:18:31 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:18:31 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:18:36.513Z] Jul 19, 2023 9:18:36 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:18:36 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:18:36.589Z] Jul 19, 2023 9:18:36 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:18:36 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:18:37.082Z] Jul 19, 2023 9:18:37 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:18:37 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:18:56.096Z] Jul 19, 2023 9:18:56 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:18:56 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:19:16.625Z] Jul 19, 2023 9:19:16 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:19:16 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:19:52.127Z] Jul 19, 2023 9:19:52 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:19:52 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:20:37.146Z] Jul 19, 2023 9:20:37 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:20:37 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:21:22.173Z] Jul 19, 2023 9:21:22 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:21:22 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:22:37.194Z] Jul 19, 2023 9:22:37 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:22:37 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:23:52.213Z] Jul 19, 2023 9:23:52 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:23:52 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:25:07.774Z] Jul 19, 2023 9:25:07 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:25:07 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:26:07.787Z] Jul 19, 2023 9:26:07 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:26:07 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:27:13.534Z] Jul 19, 2023 9:27:13 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:27:13 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:27:13.536Z] Jul 19, 2023 9:27:13 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:27:13 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:27:22.801Z] Jul 19, 2023 9:27:22 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:27:22 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:27:55.231Z] Jul 19, 2023 9:27:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:27:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:27:55.268Z] Jul 19, 2023 9:27:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:27:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:27:55.276Z] Jul 19, 2023 9:27:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:27:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:28:18.286Z] Jul 19, 2023 9:28:18 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:28:18 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:28:18.336Z] Jul 19, 2023 9:28:18 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:28:18 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:28:35.043Z] Jul 19, 2023 9:28:35 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:28:35 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:29:00.209Z] Jul 19, 2023 9:29:00 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:29:00 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:29:00.260Z] Jul 19, 2023 9:29:00 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:29:00 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:29:25.009Z] Jul 19, 2023 9:29:25 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:29:25 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:29:25.030Z] Jul 19, 2023 9:29:25 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:29:25 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:29:49.502Z] Jul 19, 2023 9:29:49 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:29:49 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:29:49.521Z] Jul 19, 2023 9:29:49 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:29:49 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:29:55.584Z] Jul 19, 2023 9:29:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 19, 2023 9:29:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:29:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 19, 2023 9:29:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:29:55.750Z] Jul 19, 2023 9:29:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:29:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:30:19.526Z] Jul 19, 2023 9:30:19 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:30:19 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:30:49.551Z] Jul 19, 2023 9:30:49 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:30:49 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:30:49.557Z] Jul 19, 2023 9:30:49 AM com.google.cloud.datastore.emulator.firestore.webchannel.FirestoreV1WebChannelAdapter$FirestoreWriteHandler onClose
INFO: channel closed
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:30:49 AM com.google.cloud.datastore.emulator.firestore.webchannel.FirestoreV1WebChannelAdapter$FirestoreWriteHandler onClose\nINFO: channel closed\n"}}
[debug] [2023-07-19T08:30:53.802Z] Jul 19, 2023 9:30:53 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:30:53 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:30:53.822Z] Jul 19, 2023 9:30:53 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:30:53 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:30:53.831Z] Jul 19, 2023 9:30:53 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:30:53 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:31:04.279Z] Jul 19, 2023 9:31:04 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:31:04 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:31:04.282Z] Jul 19, 2023 9:31:04 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:31:04 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:31:38.904Z] Jul 19, 2023 9:31:38 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:31:38 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:31:38.905Z] Jul 19, 2023 9:31:38 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:31:38 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:31:53.890Z] Jul 19, 2023 9:31:53 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:31:53 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:31:53.903Z] Jul 19, 2023 9:31:53 AM com.google.cloud.datastore.emulator.firestore.webchannel.FirestoreV1WebChannelAdapter$FirestoreWriteHandler onClose
INFO: channel closed
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:31:53 AM com.google.cloud.datastore.emulator.firestore.webchannel.FirestoreV1WebChannelAdapter$FirestoreWriteHandler onClose\nINFO: channel closed\n"}}
[debug] [2023-07-19T08:32:38.937Z] Jul 19, 2023 9:32:38 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:32:38 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:33:38.952Z] Jul 19, 2023 9:33:38 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:33:38 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:34:24.884Z] Jul 19, 2023 9:34:24 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:34:24 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:35:40.885Z] Jul 19, 2023 9:35:40 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:35:40 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:36:40.949Z] Jul 19, 2023 9:36:40 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:36:40 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:37:40.993Z] Jul 19, 2023 9:37:40 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:37:40 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:38:56.889Z] Jul 19, 2023 9:38:56 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:38:56 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:40:12.889Z] Jul 19, 2023 9:40:12 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:40:12 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:41:12.909Z] Jul 19, 2023 9:41:12 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:41:12 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:42:12.926Z] Jul 19, 2023 9:42:12 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:42:12 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:43:28.888Z] Jul 19, 2023 9:43:28 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:43:28 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:44:44.889Z] Jul 19, 2023 9:44:44 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:44:44 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:46:00.889Z] Jul 19, 2023 9:46:00 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:46:00 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:47:16.889Z] Jul 19, 2023 9:47:16 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:47:16 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:48:16.907Z] Jul 19, 2023 9:48:16 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:48:16 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:49:16.922Z] Jul 19, 2023 9:49:16 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:49:16 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:50:02.888Z] Jul 19, 2023 9:50:02 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:50:02 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:50:48.888Z] Jul 19, 2023 9:50:48 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:50:48 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:51:00.775Z] Jul 19, 2023 9:51:00 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:51:00 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:51:00.801Z] Jul 19, 2023 9:51:00 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:51:00 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:51:07.416Z] Jul 19, 2023 9:51:07 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 19, 2023 9:51:07 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 19, 2023 9:51:07 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:51:07 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 19, 2023 9:51:07 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 19, 2023 9:51:07 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:51:48.903Z] Jul 19, 2023 9:51:48 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:51:48 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:52:48.929Z] Jul 19, 2023 9:52:48 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:52:48 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:54:04.894Z] Jul 19, 2023 9:54:04 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:54:04 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:55:04.917Z] Jul 19, 2023 9:55:04 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:55:04 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:56:04.943Z] Jul 19, 2023 9:56:04 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:56:04 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:57:20.894Z] Jul 19, 2023 9:57:20 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:57:20 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:58:06.889Z] Jul 19, 2023 9:58:06 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:58:06 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T08:58:14.502Z] Jul 19, 2023 9:58:14 AM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketChannelHandler channelClosed
INFO: Websocket client disconnected
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 9:58:14 AM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketChannelHandler channelClosed\nINFO: Websocket client disconnected\n"}}
[debug] [2023-07-19T09:24:20.936Z] Jul 19, 2023 10:24:20 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:24:20 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:24:20.937Z] Jul 19, 2023 10:24:20 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:24:20 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:28:20.922Z] Jul 19, 2023 10:28:20 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:28:20 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:29:41.542Z] Jul 19, 2023 10:29:41 AM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketChannelHandler initChannel
INFO: Connected to new websocket client
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:29:41 AM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketChannelHandler initChannel\nINFO: Connected to new websocket client\n"}}
[debug] [2023-07-19T09:29:41.544Z] Jul 19, 2023 10:29:41 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:29:41 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:29:41.731Z] Jul 19, 2023 10:29:41 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:29:41 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:29:41.880Z] Jul 19, 2023 10:29:41 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:29:41 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:29:42.131Z] Jul 19, 2023 10:29:42 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:29:42 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:30:57.910Z] Jul 19, 2023 10:30:57 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:30:57 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:32:13.888Z] Jul 19, 2023 10:32:13 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:32:13 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:32:59.889Z] Jul 19, 2023 10:32:59 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:32:59 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:33:59.908Z] Jul 19, 2023 10:33:59 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:33:59 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:34:45.888Z] Jul 19, 2023 10:34:45 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:34:45 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:36:01.889Z] Jul 19, 2023 10:36:01 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:36:01 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:37:17.889Z] Jul 19, 2023 10:37:17 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:37:17 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:38:17.907Z] Jul 19, 2023 10:38:17 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:38:17 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:39:31.401Z] Jul 19, 2023 10:39:31 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 19, 2023 10:39:31 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:39:31 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 19, 2023 10:39:31 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:39:31.406Z] Jul 19, 2023 10:39:31 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:39:31 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:39:33.885Z] Jul 19, 2023 10:39:33 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:39:33 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:40:19.885Z] Jul 19, 2023 10:40:19 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:40:19 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:41:19.900Z] Jul 19, 2023 10:41:19 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:41:19 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:42:35.888Z] Jul 19, 2023 10:42:35 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:42:35 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:43:51.888Z] Jul 19, 2023 10:43:51 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:43:51 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:45:07.884Z] Jul 19, 2023 10:45:07 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:45:07 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:46:15.900Z] Jul 19, 2023 10:46:15 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:46:15 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:46:15.907Z] Jul 19, 2023 10:46:15 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:46:15 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:46:15.908Z] Jul 19, 2023 10:46:15 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:46:15 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:46:23.884Z] Jul 19, 2023 10:46:23 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:46:23 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:47:09.893Z] Jul 19, 2023 10:47:09 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:47:09 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:47:55.884Z] Jul 19, 2023 10:47:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:47:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:48:41.884Z] Jul 19, 2023 10:48:41 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:48:41 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:49:27.888Z] Jul 19, 2023 10:49:27 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:49:27 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:50:27.900Z] Jul 19, 2023 10:50:27 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:50:27 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:51:13.885Z] Jul 19, 2023 10:51:13 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:51:13 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:51:59.888Z] Jul 19, 2023 10:51:59 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:51:59 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:53:15.886Z] Jul 19, 2023 10:53:15 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:53:15 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:54:01.889Z] Jul 19, 2023 10:54:01 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:54:01 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:54:47.888Z] Jul 19, 2023 10:54:47 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:54:47 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:55:47.907Z] Jul 19, 2023 10:55:47 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:55:47 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:56:33.889Z] Jul 19, 2023 10:56:33 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:56:33 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:57:49.889Z] Jul 19, 2023 10:57:49 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:57:49 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:59:05.889Z] Jul 19, 2023 10:59:05 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:59:05 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T09:59:51.889Z] Jul 19, 2023 10:59:51 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 10:59:51 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:01:07.886Z] Jul 19, 2023 11:01:07 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:01:07 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:01:53.888Z] Jul 19, 2023 11:01:53 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:01:53 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:02:16.609Z] Jul 19, 2023 11:02:16 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:02:16 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:02:16.614Z] Jul 19, 2023 11:02:16 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:02:16 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:02:16.627Z] Jul 19, 2023 11:02:16 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:02:16 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:02:39.888Z] Jul 19, 2023 11:02:39 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:02:39 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:03:55.892Z] Jul 19, 2023 11:03:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:03:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:04:41.884Z] Jul 19, 2023 11:04:41 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:04:41 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:05:27.887Z] Jul 19, 2023 11:05:27 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:05:27 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:06:13.889Z] Jul 19, 2023 11:06:13 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:06:13 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:06:45.800Z] Jul 19, 2023 11:06:45 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:06:45 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:06:45.805Z] Jul 19, 2023 11:06:45 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:06:45 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:06:45.809Z] Jul 19, 2023 11:06:45 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:06:45 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:07:13.932Z] Jul 19, 2023 11:07:13 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:07:13 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:07:59.890Z] Jul 19, 2023 11:07:59 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:07:59 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:09:15.884Z] Jul 19, 2023 11:09:15 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:09:15 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:10:15.896Z] Jul 19, 2023 11:10:15 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:10:15 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:11:31.888Z] Jul 19, 2023 11:11:31 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:11:31 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:12:47.885Z] Jul 19, 2023 11:12:47 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:12:47 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:13:33.883Z] Jul 19, 2023 11:13:33 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:13:33 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:14:19.884Z] Jul 19, 2023 11:14:19 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:14:19 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:15:05.884Z] Jul 19, 2023 11:15:05 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:15:05 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:16:05.891Z] Jul 19, 2023 11:16:05 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:16:05 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:16:51.884Z] Jul 19, 2023 11:16:51 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:16:51 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:17:37.884Z] Jul 19, 2023 11:17:37 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:17:37 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:18:04.222Z] Jul 19, 2023 11:18:04 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:18:04 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:18:04.222Z] Jul 19, 2023 11:18:04 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 19, 2023 11:18:04 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:18:04 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 19, 2023 11:18:04 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:18:23.891Z] Jul 19, 2023 11:18:23 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:18:23 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:19:09.883Z] Jul 19, 2023 11:19:09 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:19:09 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:19:55.889Z] Jul 19, 2023 11:19:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:19:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:20:41.891Z] Jul 19, 2023 11:20:41 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:20:41 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:21:41.917Z] Jul 19, 2023 11:21:41 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:21:41 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:22:57.884Z] Jul 19, 2023 11:22:57 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:22:57 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:23:57.899Z] Jul 19, 2023 11:23:57 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:23:57 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:25:13.889Z] Jul 19, 2023 11:25:13 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:25:13 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:25:59.888Z] Jul 19, 2023 11:25:59 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:25:59 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:27:15.888Z] Jul 19, 2023 11:27:15 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:27:15 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:28:01.886Z] Jul 19, 2023 11:28:01 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:28:01 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:29:01.897Z] Jul 19, 2023 11:29:01 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:29:01 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:30:01.909Z] Jul 19, 2023 11:30:01 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:30:01 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:30:19.839Z] Jul 19, 2023 11:30:19 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 19, 2023 11:30:19 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:30:19 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 19, 2023 11:30:19 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:30:19.840Z] Jul 19, 2023 11:30:19 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:30:19 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:31:17.885Z] Jul 19, 2023 11:31:17 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:31:17 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:32:17.906Z] Jul 19, 2023 11:32:17 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:32:17 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:33:33.888Z] Jul 19, 2023 11:33:33 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:33:33 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:34:49.885Z] Jul 19, 2023 11:34:49 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:34:49 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:35:35.890Z] Jul 19, 2023 11:35:35 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:35:35 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:36:51.888Z] Jul 19, 2023 11:36:51 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:36:51 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:38:07.888Z] Jul 19, 2023 11:38:07 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:38:07 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:39:07.919Z] Jul 19, 2023 11:39:07 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:39:07 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:39:53.888Z] Jul 19, 2023 11:39:53 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:39:53 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:41:09.887Z] Jul 19, 2023 11:41:09 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:41:09 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:41:55.887Z] Jul 19, 2023 11:41:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:41:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:42:41.888Z] Jul 19, 2023 11:42:41 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:42:41 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:43:57.888Z] Jul 19, 2023 11:43:57 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:43:57 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:45:13.888Z] Jul 19, 2023 11:45:13 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:45:13 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:46:29.888Z] Jul 19, 2023 11:46:29 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:46:29 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:47:38.666Z] Jul 19, 2023 11:47:38 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:47:38 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:47:38.671Z] Jul 19, 2023 11:47:38 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:47:38 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:47:38.679Z] Jul 19, 2023 11:47:38 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:47:38 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:47:45.896Z] Jul 19, 2023 11:47:45 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:47:45 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:48:45.954Z] Jul 19, 2023 11:48:45 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:48:45 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:50:01.886Z] Jul 19, 2023 11:50:01 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:50:01 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:51:01.895Z] Jul 19, 2023 11:51:01 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:51:01 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:52:17.884Z] Jul 19, 2023 11:52:17 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:52:17 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:53:17.894Z] Jul 19, 2023 11:53:17 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:53:17 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:54:03.890Z] Jul 19, 2023 11:54:03 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:54:03 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:54:49.883Z] Jul 19, 2023 11:54:49 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:54:49 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:54:55.663Z] Jul 19, 2023 11:54:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 19, 2023 11:54:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:54:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 19, 2023 11:54:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:54:55.667Z] Jul 19, 2023 11:54:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:54:55 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:55:32.834Z] Jul 19, 2023 11:55:32 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 19, 2023 11:55:32 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:55:32 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 19, 2023 11:55:32 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:55:32.838Z] Jul 19, 2023 11:55:32 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:55:32 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:55:34.783Z] Jul 19, 2023 11:55:34 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:55:34 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:55:34.868Z] Jul 19, 2023 11:55:34 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:55:34 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:55:35.444Z] Jul 19, 2023 11:55:35 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:55:35 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:55:35.459Z] Jul 19, 2023 11:55:35 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:55:35 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:55:44.378Z] Jul 19, 2023 11:55:44 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:55:44 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:55:44.397Z] Jul 19, 2023 11:55:44 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:55:44 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:55:44.403Z] Jul 19, 2023 11:55:44 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:55:44 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:55:51.730Z] Jul 19, 2023 11:55:51 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:55:51 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:56:36.888Z] Jul 19, 2023 11:56:36 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:56:36 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:56:51.752Z] Jul 19, 2023 11:56:51 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:56:51 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:56:51.909Z] Jul 19, 2023 11:56:51 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:56:51 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:56:51.914Z] Jul 19, 2023 11:56:51 AM com.google.cloud.datastore.emulator.firestore.webchannel.FirestoreV1WebChannelAdapter$FirestoreWriteHandler onClose
INFO: channel closed
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:56:51 AM com.google.cloud.datastore.emulator.firestore.webchannel.FirestoreV1WebChannelAdapter$FirestoreWriteHandler onClose\nINFO: channel closed\n"}}
[debug] [2023-07-19T10:57:36.905Z] Jul 19, 2023 11:57:36 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:57:36 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:58:52.889Z] Jul 19, 2023 11:58:52 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:58:52 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T10:59:38.901Z] Jul 19, 2023 11:59:38 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 11:59:38 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:00:54.888Z] Jul 19, 2023 12:00:54 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:00:54 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:01:40.888Z] Jul 19, 2023 12:01:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:01:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:02:56.888Z] Jul 19, 2023 12:02:56 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:02:56 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:04:09.445Z] Jul 19, 2023 12:04:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:04:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:04:09.452Z] Jul 19, 2023 12:04:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:04:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:04:09.456Z] Jul 19, 2023 12:04:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:04:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:04:12.884Z] Jul 19, 2023 12:04:12 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:04:12 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:04:58.888Z] Jul 19, 2023 12:04:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:04:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:05:44.891Z] Jul 19, 2023 12:05:44 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:05:44 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:07:00.884Z] Jul 19, 2023 12:07:00 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:07:00 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:07:46.884Z] Jul 19, 2023 12:07:46 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:07:46 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:08:46.893Z] Jul 19, 2023 12:08:46 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:08:46 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:09:05.786Z] Jul 19, 2023 12:09:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 19, 2023 12:09:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 19, 2023 12:09:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:09:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 19, 2023 12:09:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 19, 2023 12:09:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:09:59.502Z] Jul 19, 2023 12:09:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:09:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:09:59.510Z] Jul 19, 2023 12:09:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:09:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:09:59.518Z] Jul 19, 2023 12:09:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:09:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:09:59.544Z] Jul 19, 2023 12:09:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:09:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:09:59.581Z] Jul 19, 2023 12:09:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:09:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:09:59.633Z] Jul 19, 2023 12:09:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:09:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:10:10.778Z] Jul 19, 2023 12:10:10 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:10:10 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:10:28.684Z] Jul 19, 2023 12:10:28 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:10:28 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:10:48.124Z] Jul 19, 2023 12:10:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 19, 2023 12:10:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 19, 2023 12:10:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:10:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 19, 2023 12:10:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 19, 2023 12:10:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:10:58.707Z] Jul 19, 2023 12:10:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 19, 2023 12:10:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:10:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 19, 2023 12:10:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:11:28.907Z] Jul 19, 2023 12:11:28 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:11:28 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:11:28.913Z] Jul 19, 2023 12:11:28 PM com.google.cloud.datastore.emulator.firestore.webchannel.FirestoreV1WebChannelAdapter$FirestoreWriteHandler onClose
INFO: channel closed
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:11:28 PM com.google.cloud.datastore.emulator.firestore.webchannel.FirestoreV1WebChannelAdapter$FirestoreWriteHandler onClose\nINFO: channel closed\n"}}
[debug] [2023-07-19T11:11:43.884Z] Jul 19, 2023 12:11:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:11:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:12:43.893Z] Jul 19, 2023 12:12:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:12:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:13:59.888Z] Jul 19, 2023 12:13:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:13:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:14:59.904Z] Jul 19, 2023 12:14:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:14:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:15:45.886Z] Jul 19, 2023 12:15:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:15:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:16:04.947Z] Jul 19, 2023 12:16:04 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:16:04 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:16:04.949Z] Jul 19, 2023 12:16:04 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:16:04 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:16:04.952Z] Jul 19, 2023 12:16:04 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:16:04 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:16:27.535Z] Jul 19, 2023 12:16:27 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:16:27 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:16:27.565Z] Jul 19, 2023 12:16:27 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:16:27 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:16:27.579Z] Jul 19, 2023 12:16:27 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:16:27 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:16:43.778Z] Jul 19, 2023 12:16:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:16:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:16:43.787Z] Jul 19, 2023 12:16:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:16:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:17:04.878Z] Jul 19, 2023 12:17:04 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:17:04 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:17:22.387Z] Jul 19, 2023 12:17:22 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:17:22 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:17:22.405Z] Jul 19, 2023 12:17:22 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:17:22 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:17:52.399Z] Jul 19, 2023 12:17:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:17:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:18:22.412Z] Jul 19, 2023 12:18:22 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:18:22 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:18:22.885Z] Jul 19, 2023 12:18:22 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:18:22 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:18:22.888Z] Jul 19, 2023 12:18:22 PM com.google.cloud.datastore.emulator.firestore.webchannel.FirestoreV1WebChannelAdapter$FirestoreWriteHandler onClose
INFO: channel closed
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:18:22 PM com.google.cloud.datastore.emulator.firestore.webchannel.FirestoreV1WebChannelAdapter$FirestoreWriteHandler onClose\nINFO: channel closed\n"}}
[debug] [2023-07-19T11:19:07.895Z] Jul 19, 2023 12:19:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:19:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:20:07.924Z] Jul 19, 2023 12:20:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:20:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:20:53.884Z] Jul 19, 2023 12:20:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:20:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:21:39.884Z] Jul 19, 2023 12:21:39 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:21:39 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:22:25.885Z] Jul 19, 2023 12:22:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:22:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:23:25.904Z] Jul 19, 2023 12:23:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:23:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:24:41.888Z] Jul 19, 2023 12:24:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:24:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:25:41.922Z] Jul 19, 2023 12:25:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:25:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:26:57.885Z] Jul 19, 2023 12:26:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:26:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:27:57.921Z] Jul 19, 2023 12:27:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:27:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:27:58.185Z] Jul 19, 2023 12:27:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:27:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:27:58.192Z] Jul 19, 2023 12:27:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:27:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:27:58.193Z] Jul 19, 2023 12:27:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:27:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:28:57.941Z] Jul 19, 2023 12:28:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:28:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:30:13.885Z] Jul 19, 2023 12:30:13 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:30:13 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:30:59.884Z] Jul 19, 2023 12:30:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:30:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:31:45.884Z] Jul 19, 2023 12:31:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:31:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:32:45.893Z] Jul 19, 2023 12:32:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:32:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:33:31.884Z] Jul 19, 2023 12:33:31 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:33:31 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:34:47.884Z] Jul 19, 2023 12:34:47 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:34:47 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:35:33.884Z] Jul 19, 2023 12:35:33 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:35:33 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:36:19.883Z] Jul 19, 2023 12:36:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:36:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:37:05.888Z] Jul 19, 2023 12:37:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:37:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:37:36.510Z] Jul 19, 2023 12:37:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:37:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:37:36.513Z] Jul 19, 2023 12:37:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:37:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:37:36.518Z] Jul 19, 2023 12:37:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:37:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:38:05.906Z] Jul 19, 2023 12:38:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:38:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:39:05.926Z] Jul 19, 2023 12:39:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:39:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:40:05.941Z] Jul 19, 2023 12:40:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:40:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:40:51.888Z] Jul 19, 2023 12:40:51 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:40:51 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:42:07.888Z] Jul 19, 2023 12:42:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:42:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:42:53.888Z] Jul 19, 2023 12:42:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:42:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:44:09.887Z] Jul 19, 2023 12:44:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:44:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:45:25.888Z] Jul 19, 2023 12:45:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:45:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:46:11.887Z] Jul 19, 2023 12:46:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:46:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:46:57.887Z] Jul 19, 2023 12:46:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:46:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:47:43.888Z] Jul 19, 2023 12:47:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:47:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:48:59.888Z] Jul 19, 2023 12:48:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:48:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:49:45.888Z] Jul 19, 2023 12:49:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:49:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:51:01.888Z] Jul 19, 2023 12:51:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:51:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:52:01.903Z] Jul 19, 2023 12:52:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:52:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:53:01.917Z] Jul 19, 2023 12:53:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:53:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:54:17.888Z] Jul 19, 2023 12:54:17 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:54:17 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:55:03.890Z] Jul 19, 2023 12:55:03 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:55:03 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:56:19.888Z] Jul 19, 2023 12:56:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:56:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:57:19.903Z] Jul 19, 2023 12:57:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:57:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:58:05.887Z] Jul 19, 2023 12:58:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:58:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:58:51.888Z] Jul 19, 2023 12:58:51 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:58:51 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T11:59:51.903Z] Jul 19, 2023 12:59:51 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 12:59:51 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:01:07.888Z] Jul 19, 2023 1:01:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:01:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:02:23.887Z] Jul 19, 2023 1:02:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:02:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:03:09.887Z] Jul 19, 2023 1:03:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:03:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:04:25.888Z] Jul 19, 2023 1:04:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:04:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:05:41.888Z] Jul 19, 2023 1:05:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:05:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:06:41.903Z] Jul 19, 2023 1:06:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:06:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:07:57.887Z] Jul 19, 2023 1:07:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:07:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:08:43.888Z] Jul 19, 2023 1:08:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:08:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:09:29.888Z] Jul 19, 2023 1:09:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:09:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:10:15.888Z] Jul 19, 2023 1:10:15 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:10:15 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:11:15.902Z] Jul 19, 2023 1:11:15 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:11:15 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:12:31.888Z] Jul 19, 2023 1:12:31 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:12:31 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:13:17.888Z] Jul 19, 2023 1:13:17 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:13:17 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:14:17.903Z] Jul 19, 2023 1:14:17 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:14:17 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:15:33.888Z] Jul 19, 2023 1:15:33 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:15:33 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:16:19.888Z] Jul 19, 2023 1:16:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:16:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:17:05.888Z] Jul 19, 2023 1:17:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:17:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:17:51.888Z] Jul 19, 2023 1:17:51 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:17:51 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:18:37.887Z] Jul 19, 2023 1:18:37 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:18:37 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:19:23.888Z] Jul 19, 2023 1:19:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:19:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:20:39.888Z] Jul 19, 2023 1:20:39 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:20:39 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:21:39.904Z] Jul 19, 2023 1:21:39 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:21:39 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:22:25.888Z] Jul 19, 2023 1:22:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:22:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:23:41.887Z] Jul 19, 2023 1:23:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:23:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:24:27.888Z] Jul 19, 2023 1:24:27 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:24:27 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:25:13.889Z] Jul 19, 2023 1:25:13 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:25:13 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:26:29.888Z] Jul 19, 2023 1:26:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:26:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:27:45.888Z] Jul 19, 2023 1:27:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:27:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:28:31.888Z] Jul 19, 2023 1:28:31 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:28:31 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:29:47.888Z] Jul 19, 2023 1:29:47 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:29:47 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:31:03.887Z] Jul 19, 2023 1:31:03 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:31:03 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:32:19.888Z] Jul 19, 2023 1:32:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:32:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:33:19.905Z] Jul 19, 2023 1:33:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:33:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:34:35.888Z] Jul 19, 2023 1:34:35 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:34:35 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:35:21.890Z] Jul 19, 2023 1:35:21 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:35:21 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:36:07.888Z] Jul 19, 2023 1:36:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:36:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:36:53.888Z] Jul 19, 2023 1:36:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:36:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:38:09.888Z] Jul 19, 2023 1:38:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:38:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:38:55.888Z] Jul 19, 2023 1:38:55 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:38:55 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:40:11.888Z] Jul 19, 2023 1:40:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:40:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:41:27.888Z] Jul 19, 2023 1:41:27 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:41:27 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:42:43.888Z] Jul 19, 2023 1:42:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:42:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:43:29.888Z] Jul 19, 2023 1:43:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:43:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:44:15.888Z] Jul 19, 2023 1:44:15 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:44:15 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:45:01.888Z] Jul 19, 2023 1:45:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:45:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:46:17.888Z] Jul 19, 2023 1:46:17 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:46:17 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:47:33.888Z] Jul 19, 2023 1:47:33 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:47:33 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:48:19.888Z] Jul 19, 2023 1:48:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:48:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:49:35.888Z] Jul 19, 2023 1:49:35 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:49:35 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:50:21.888Z] Jul 19, 2023 1:50:21 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:50:21 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:51:21.902Z] Jul 19, 2023 1:51:21 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:51:21 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:52:37.888Z] Jul 19, 2023 1:52:37 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:52:37 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:53:52.393Z] Jul 19, 2023 1:53:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:53:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:53:52.400Z] Jul 19, 2023 1:53:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:53:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:53:52.402Z] Jul 19, 2023 1:53:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:53:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:53:52.421Z] Jul 19, 2023 1:53:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:53:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:53:53.888Z] Jul 19, 2023 1:53:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:53:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:54:39.888Z] Jul 19, 2023 1:54:39 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:54:39 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:55:25.888Z] Jul 19, 2023 1:55:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:55:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:56:11.884Z] Jul 19, 2023 1:56:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:56:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:57:11.890Z] Jul 19, 2023 1:57:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:57:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:58:11.903Z] Jul 19, 2023 1:58:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:58:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T12:58:57.888Z] Jul 19, 2023 1:58:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 1:58:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:00:13.895Z] Jul 19, 2023 2:00:13 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:00:13 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:01:29.889Z] Jul 19, 2023 2:01:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:01:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:02:45.884Z] Jul 19, 2023 2:02:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:02:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:03:31.888Z] Jul 19, 2023 2:03:31 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:03:31 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:04:17.888Z] Jul 19, 2023 2:04:17 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:04:17 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:05:17.896Z] Jul 19, 2023 2:05:17 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:05:17 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:06:17.912Z] Jul 19, 2023 2:06:17 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:06:17 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:07:03.888Z] Jul 19, 2023 2:07:03 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:07:03 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:07:49.891Z] Jul 19, 2023 2:07:49 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:07:49 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:09:05.884Z] Jul 19, 2023 2:09:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:09:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:09:51.887Z] Jul 19, 2023 2:09:51 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:09:51 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:10:37.888Z] Jul 19, 2023 2:10:37 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:10:37 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:11:23.883Z] Jul 19, 2023 2:11:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:11:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:12:08.080Z] Jul 19, 2023 2:12:08 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:12:08 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:12:08.081Z] Jul 19, 2023 2:12:08 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:12:08 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:12:08.081Z] Jul 19, 2023 2:12:08 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:12:08 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:12:09.888Z] Jul 19, 2023 2:12:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:12:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:12:55.884Z] Jul 19, 2023 2:12:55 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:12:55 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:13:41.884Z] Jul 19, 2023 2:13:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:13:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:14:57.888Z] Jul 19, 2023 2:14:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:14:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:16:13.887Z] Jul 19, 2023 2:16:13 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:16:13 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:17:29.887Z] Jul 19, 2023 2:17:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:17:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:18:29.909Z] Jul 19, 2023 2:18:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:18:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:19:29.928Z] Jul 19, 2023 2:19:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:19:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:20:29.936Z] Jul 19, 2023 2:20:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:20:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:21:29.950Z] Jul 19, 2023 2:21:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:21:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:22:29.985Z] Jul 19, 2023 2:22:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:22:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:23:24.835Z] Jul 19, 2023 2:23:24 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:23:24 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:23:24.836Z] Jul 19, 2023 2:23:24 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 19, 2023 2:23:24 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:23:24 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 19, 2023 2:23:24 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:23:30.004Z] Jul 19, 2023 2:23:30 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:23:30 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:24:30.012Z] Jul 19, 2023 2:24:30 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:24:30 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:24:41.649Z] Jul 19, 2023 2:24:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:24:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:24:41.666Z] Jul 19, 2023 2:24:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:24:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:24:41.674Z] Jul 19, 2023 2:24:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:24:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:24:41.721Z] Jul 19, 2023 2:24:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:24:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:25:41.908Z] Jul 19, 2023 2:25:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:25:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:25:41.915Z] Jul 19, 2023 2:25:41 PM com.google.cloud.datastore.emulator.firestore.webchannel.FirestoreV1WebChannelAdapter$FirestoreWriteHandler onClose
INFO: channel closed
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:25:41 PM com.google.cloud.datastore.emulator.firestore.webchannel.FirestoreV1WebChannelAdapter$FirestoreWriteHandler onClose\nINFO: channel closed\n"}}
[debug] [2023-07-19T13:25:56.888Z] Jul 19, 2023 2:25:56 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:25:56 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:26:42.884Z] Jul 19, 2023 2:26:42 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:26:42 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:27:28.888Z] Jul 19, 2023 2:27:28 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:27:28 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:28:44.889Z] Jul 19, 2023 2:28:44 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:28:44 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:29:30.889Z] Jul 19, 2023 2:29:30 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:29:30 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:30:16.887Z] Jul 19, 2023 2:30:16 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:30:16 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:31:02.888Z] Jul 19, 2023 2:31:02 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:31:02 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:32:02.902Z] Jul 19, 2023 2:32:02 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:32:02 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:32:48.889Z] Jul 19, 2023 2:32:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:32:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:33:34.885Z] Jul 19, 2023 2:33:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:33:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:34:50.888Z] Jul 19, 2023 2:34:50 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:34:50 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:35:36.885Z] Jul 19, 2023 2:35:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:35:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:36:22.884Z] Jul 19, 2023 2:36:22 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:36:22 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:37:08.890Z] Jul 19, 2023 2:37:08 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:37:08 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:37:54.889Z] Jul 19, 2023 2:37:54 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:37:54 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:38:40.888Z] Jul 19, 2023 2:38:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:38:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:39:40.910Z] Jul 19, 2023 2:39:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:39:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:40:26.884Z] Jul 19, 2023 2:40:26 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:40:26 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:41:26.906Z] Jul 19, 2023 2:41:26 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:41:26 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:42:26.920Z] Jul 19, 2023 2:42:26 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:42:26 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:42:40.669Z] Jul 19, 2023 2:42:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:42:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:42:40.674Z] Jul 19, 2023 2:42:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:42:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:42:40.679Z] Jul 19, 2023 2:42:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:42:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:43:26.933Z] Jul 19, 2023 2:43:26 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:43:26 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:44:12.883Z] Jul 19, 2023 2:44:12 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:44:12 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:44:58.883Z] Jul 19, 2023 2:44:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:44:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:45:58.895Z] Jul 19, 2023 2:45:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:45:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:47:14.887Z] Jul 19, 2023 2:47:14 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:47:14 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:48:30.887Z] Jul 19, 2023 2:48:30 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:48:30 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:48:48.211Z] Jul 19, 2023 2:48:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:48:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:48:48.220Z] Jul 19, 2023 2:48:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:48:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:48:48.225Z] Jul 19, 2023 2:48:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:48:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:49:30.903Z] Jul 19, 2023 2:49:30 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:49:30 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:50:16.888Z] Jul 19, 2023 2:50:16 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:50:16 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:51:32.888Z] Jul 19, 2023 2:51:32 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:51:32 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:52:48.885Z] Jul 19, 2023 2:52:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:52:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:53:34.899Z] Jul 19, 2023 2:53:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:53:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:54:20.885Z] Jul 19, 2023 2:54:20 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:54:20 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:54:23.226Z] Jul 19, 2023 2:54:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:54:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:54:23.231Z] Jul 19, 2023 2:54:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 19, 2023 2:54:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:54:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 19, 2023 2:54:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:55:36.888Z] Jul 19, 2023 2:55:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:55:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:56:52.888Z] Jul 19, 2023 2:56:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:56:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:58:08.888Z] Jul 19, 2023 2:58:08 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:58:08 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:58:54.887Z] Jul 19, 2023 2:58:54 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:58:54 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T13:59:40.887Z] Jul 19, 2023 2:59:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 2:59:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:00:40.903Z] Jul 19, 2023 3:00:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:00:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:01:40.913Z] Jul 19, 2023 3:01:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:01:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:02:56.884Z] Jul 19, 2023 3:02:56 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:02:56 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:03:42.888Z] Jul 19, 2023 3:03:42 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:03:42 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:04:28.885Z] Jul 19, 2023 3:04:28 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:04:28 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:05:44.884Z] Jul 19, 2023 3:05:44 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:05:44 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:06:26.179Z] Jul 19, 2023 3:06:26 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:06:26 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:06:26.217Z] Jul 19, 2023 3:06:26 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:06:26 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:06:30.886Z] Jul 19, 2023 3:06:30 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:06:30 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:06:34.724Z] Jul 19, 2023 3:06:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 19, 2023 3:06:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 19, 2023 3:06:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:06:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 19, 2023 3:06:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 19, 2023 3:06:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:06:40.677Z] Jul 19, 2023 3:06:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:06:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:07:46.884Z] Jul 19, 2023 3:07:46 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:07:46 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:08:46.905Z] Jul 19, 2023 3:08:46 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:08:46 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:10:02.884Z] Jul 19, 2023 3:10:02 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:10:02 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:10:48.888Z] Jul 19, 2023 3:10:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:10:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:11:48.187Z] Jul 19, 2023 3:11:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:11:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:12:48.201Z] Jul 19, 2023 3:12:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:12:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:13:48.210Z] Jul 19, 2023 3:13:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:13:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:14:48.224Z] Jul 19, 2023 3:14:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:14:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:15:48.240Z] Jul 19, 2023 3:15:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:15:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:16:33.887Z] Jul 19, 2023 3:16:33 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:16:33 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:17:49.888Z] Jul 19, 2023 3:17:49 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:17:49 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:17:52.715Z] Jul 19, 2023 3:17:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:17:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:17:52.719Z] Jul 19, 2023 3:17:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
Jul 19, 2023 3:17:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:17:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nJul 19, 2023 3:17:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:18:35.888Z] Jul 19, 2023 3:18:35 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:18:35 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:19:21.887Z] Jul 19, 2023 3:19:21 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:19:21 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:20:37.888Z] Jul 19, 2023 3:20:37 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:20:37 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:21:53.888Z] Jul 19, 2023 3:21:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:21:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:23:09.889Z] Jul 19, 2023 3:23:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:23:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:23:55.887Z] Jul 19, 2023 3:23:55 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:23:55 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:24:41.887Z] Jul 19, 2023 3:24:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:24:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:25:57.884Z] Jul 19, 2023 3:25:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:25:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:26:43.888Z] Jul 19, 2023 3:26:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:26:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:27:29.888Z] Jul 19, 2023 3:27:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:27:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:28:45.888Z] Jul 19, 2023 3:28:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:28:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:30:01.887Z] Jul 19, 2023 3:30:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:30:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:30:47.888Z] Jul 19, 2023 3:30:47 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:30:47 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:31:33.887Z] Jul 19, 2023 3:31:33 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:31:33 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:32:32.049Z] Jul 19, 2023 3:32:32 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:32:32 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:32:32.050Z] Jul 19, 2023 3:32:32 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:32:32 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:32:32.051Z] Jul 19, 2023 3:32:32 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:32:32 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:32:39.028Z] Jul 19, 2023 3:32:39 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:32:39 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:33:40.536Z] Jul 19, 2023 3:33:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:33:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:34:25.886Z] Jul 19, 2023 3:34:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:34:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:35:25.911Z] Jul 19, 2023 3:35:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:35:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:35:48.931Z] Jul 19, 2023 3:35:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:35:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:35:48.936Z] Jul 19, 2023 3:35:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:35:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:35:59.931Z] Jul 19, 2023 3:35:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:35:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:36:25.931Z] Jul 19, 2023 3:36:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:36:25 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:37:13.195Z] Jul 19, 2023 3:37:13 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:37:13 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:38:28.885Z] Jul 19, 2023 3:38:28 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:38:28 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:39:14.888Z] Jul 19, 2023 3:39:14 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:39:14 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:40:00.889Z] Jul 19, 2023 3:40:00 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:40:00 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:41:00.904Z] Jul 19, 2023 3:41:00 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:41:00 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:42:00.918Z] Jul 19, 2023 3:42:00 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:42:00 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:43:16.889Z] Jul 19, 2023 3:43:16 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:43:16 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:44:32.888Z] Jul 19, 2023 3:44:32 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:44:32 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:45:48.891Z] Jul 19, 2023 3:45:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:45:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:47:04.884Z] Jul 19, 2023 3:47:04 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:47:04 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:48:20.888Z] Jul 19, 2023 3:48:20 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:48:20 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:49:36.888Z] Jul 19, 2023 3:49:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:49:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:50:22.888Z] Jul 19, 2023 3:50:22 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:50:22 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:51:38.888Z] Jul 19, 2023 3:51:38 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:51:38 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:52:54.885Z] Jul 19, 2023 3:52:54 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:52:54 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:53:40.887Z] Jul 19, 2023 3:53:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:53:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:54:30.472Z] Jul 19, 2023 3:54:30 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:54:30 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:55:45.884Z] Jul 19, 2023 3:55:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:55:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:56:31.887Z] Jul 19, 2023 3:56:31 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:56:31 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:57:47.889Z] Jul 19, 2023 3:57:47 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:57:47 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T14:58:47.905Z] Jul 19, 2023 3:58:47 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 3:58:47 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T15:00:03.891Z] Jul 19, 2023 4:00:03 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 4:00:03 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T15:00:49.892Z] Jul 19, 2023 4:00:49 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 4:00:49 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T15:01:49.909Z] Jul 19, 2023 4:01:49 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 4:01:49 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T15:03:05.888Z] Jul 19, 2023 4:03:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 4:03:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
[debug] [2023-07-19T15:04:16.140Z] Jul 19, 2023 4:04:16 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
INFO: Detected non-HTTP/2 connection.
 {"metadata":{"emulator":{"name":"firestore"},"message":"Jul 19, 2023 4:04:16 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\n"}}
